"""
kg_plots.py
===========

Script that creates plots for the models of the KMDC datasest.

Controlled by the script found in /runs/plotprops.txt. 
Uses the base KMDC dataset for some plots, and uses the 
posteriors generated by the models to visualise the models.

Useage
------
Run from the command line:
  python kg_plots.py voxel_id plottype

Parameters
----------
voxel_id : int
  The id number of the voxel you want to graph.
plottype : str
  The kind of plot you want to create.

Additional script control is given via /runs/plotprops.txt (see that file for control options).

Author
------
Steven Blodgett <blodgett.steven.m@gmail.com>
Created on 2025-04-02
"""

import corner
import emcee
import h5py
import os
import sys
import commentjson as json
import re
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap, BoundaryNorm
from PIL import Image

from kg_grid_boundary_arrays import radius_grid_array, period_grid_array, mass_grid_array
from kg_griddefiner import *


class ReadJson:
    """Read and store the contents of a Json file in a dict."""
    def __init__(self, filename):
        """Load the Json file."""
        print('reading in the plotprops.txt file')
        self.data = json.load(open(filename))
    def outProps(self):
        """Return the parsed Json dictionary."""
        return self.data

    
def heatmap_plot(rpm_grid,results_folder,mode="all", make_gifs=True, verbose=False, fps=0.5):
    """
    Plots sequences of heatmaps from the base KMDC, iterating on mass, radius, and period.
    
    The plots are stored in /results/plots/heatmaps and /results/plots/animations.
    
    Parameters
    ----------
    rpm_grid : RPMGrid
      A grid of radius-period-mass voxels (of class RPMVoxel).
    results_folder : str
      The pathway to Kepler Globals' results folder.
    make_gifs : bool, optional
      Whether the function should make a gif from its generated heatmaps (default is True).
    verbose : bool, optional
      Whether the function should produce print statements to track its progress (default is False).
    fps : float, optional
      What the frame rate for the gifs should be (default is 0.5).
    
    Returns
    -------
    None
    """
    if mode == "all" or mode == "mass":
        make_histograms(rpm_grid,results_folder,mode="mass",make_gifs=make_gifs,verbose=verbose,fps=fps)
    if mode == "all" or mode == "period":
        make_histograms(rpm_grid,results_folder,mode="period",make_gifs=make_gifs,verbose=verbose,fps=fps)
    if mode == "all" or mode == "radius":
        make_histograms(rpm_grid,results_folder,mode="radius",make_gifs=make_gifs,verbose=verbose,fps=fps)


def get_arrays(mode):
    """Load the correct arrays for the heatmap plots."""
    if mode == "mass":
        x_array = period_grid_array
        y_array = radius_grid_array
        z_array = mass_grid_array
        search_dict = {"z":7,"z_next":8,"x":3,"y":5}
    elif mode == "period":
        x_array = radius_grid_array
        y_array = mass_grid_array
        z_array = period_grid_array
        search_dict = {"z":5,"z_next":6,"x":7,"y":3}
    elif mode == "radius":
        x_array = period_grid_array
        y_array = mass_grid_array
        z_array = radius_grid_array
        search_dict = {"z":3,"z_next":4,"x":7,"y":5}
    return x_array, y_array, z_array, search_dict


def make_histograms(rpm_grid, results_folder, mode, make_gifs=True, verbose=False, fps=0.5): ######## tidy up this script a lot
    """This function needs to be cut down to size..."""

    assert mode == "mass" or mode == "period" or mode == "radius", "heatmaps iterate over mass, period, or radius"
    
    x_array, y_array, z_array, search_dict = get_arrays(mode)

    heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","normal",mode)
    os.makedirs(heatmap_folder, exist_ok=True)

    Rmrps = rpm_grid.get_Rmrps()

    all_means = Rmrps[:,0]
    vmax = np.max(all_means*100)

    cumul_mean = np.zeros((len(y_array)-1,len(x_array)-1))
    cumul_lower = np.zeros((len(y_array)-1,len(x_array)-1))
    cumul_upper = np.zeros((len(y_array)-1,len(x_array)-1))
    is_cumul_mode = False
    for i, z in enumerate(z_array):
        
        if i == len(z_array)-1:
            is_cumul_mode = True
        if not is_cumul_mode: 
            next_z = z_array[i+1]

            mean = np.empty((len(y_array)-1,len(x_array)-1))
            lower = np.empty((len(y_array)-1,len(x_array)-1))
            upper = np.empty((len(y_array)-1,len(x_array)-1))
            annot = np.empty((len(y_array)-1, len(x_array)-1), dtype=object)

            for voxel in Rmrps:
                
                if voxel[search_dict["z"]] == z and voxel[search_dict["z_next"]] == next_z:
                    
                    x_idx = np.searchsorted(y_array, voxel[search_dict["x"]],side='right')-1
                    y_idx = np.searchsorted(x_array, voxel[search_dict["y"]],side='right')-1
                    
                    voxel[0] *= 100
                    voxel[1] *= 100
                    voxel[2] *= 100

                    mean[x_idx,y_idx] = voxel[0]
                    lower[x_idx,y_idx] = voxel[1]
                    upper[x_idx,y_idx] = voxel[2]
                    if voxel[0] == 0:
                        annot[x_idx,y_idx] = f"{voxel[0]:.1f}$^{{+{voxel[2]:.1f}}}_{{-{voxel[1]:.1f}}}$%"
                    elif voxel[0] < 1e-3:
                        annot[x_idx,y_idx] = f"{compact_sci(voxel[0])}$^{{+{compact_sci(voxel[2],1)}}}_{{-{compact_sci(voxel[1],1)}}}$%"
                    else:
                        annot[x_idx,y_idx] = f"{voxel[0]:.2f}$^{{+{voxel[2]:.3f}}}_{{-{voxel[1]:.3f}}}$%"

        if is_cumul_mode:
            mean = cumul_mean
            lower = cumul_lower
            upper = cumul_upper
            for row_idx, row in enumerate(mean):
                for col_idx, voxel_mean in enumerate(row):
                    if voxel_mean == 0:
                        annot[row_idx,col_idx] = f"{voxel_mean:.1f}$^{{+{upper[row_idx,col_idx]:.1f}}}_{{-{lower[row_idx,col_idx]:.1f}}}$%"
                    elif voxel_mean < 1e-3:
                        annot[row_idx,col_idx] = f"{compact_sci(voxel_mean)}$^{{+{compact_sci(upper[row_idx,col_idx],1)}}}_{{-{compact_sci(lower[row_idx,col_idx],1)}}}$%"
                    else:
                        annot[row_idx,col_idx] = f"{voxel_mean:.2f}$^{{+{upper[row_idx,col_idx]:.3f}}}_{{-{lower[row_idx,col_idx]:.3f}}}$%"

        
        cubehelix_blue = sns.cubehelix_palette(start=2, rot=0.2, light=0.5,dark=0.1,n_colors=20,gamma=1.2)

        colors = [(0.6,0.6,0.6)] + cubehelix_blue
        cmap = ListedColormap(colors)


        boundaries = [0] + list(np.linspace(np.nextafter(0,1), vmax,len(colors)))
        norm = BoundaryNorm(boundaries,len(colors))

        plt.figure(figsize=(10, 8),dpi=150)
        ax = sns.heatmap(mean, annot=annot, fmt='', cmap=cmap, norm=norm,#vmin=0.0, vmax=vmax,
                        cbar=False,annot_kws={"size":5.5})


        xedges = np.array(x_array)
        yedges = np.array(y_array)
        
        if not is_cumul_mode:
            heatmap_prior_line_config(ax,z,next_z,x_array,y_array,mode)


        xtick_positions = np.arange(len(xedges))
        xtick_labels = [f"{x:.2f}" if x < 1e5 else f"{x:.2e}" for x in xedges]
        ax.set_xticks(xtick_positions)
        ax.set_xticklabels(xtick_labels, rotation=45, fontsize=5)

        # Y-axis: radius bin edges
        ytick_positions = np.arange(len(yedges))
        ytick_labels = [f"{y:.2f}" if y < 1e5 else f"{y:.2e}" for y in yedges]
        ax.set_yticks(ytick_positions)
        ax.set_yticklabels(ytick_labels, rotation=0, fontsize=5)

        # Flip y-axis so smaller radii are on bottom
        ax.invert_yaxis()

        xlabel, ylabel = get_labels(mode)

        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.suptitle("$\mathcal{R}_{MRP}$ Heatmap", fontsize=25)
        if not is_cumul_mode:
            plt.title(mode+f" {z}-{next_z}")
        else:
            plt.title(mode +" (cumulative)")
        plt.tight_layout()
        if not is_cumul_mode: 
            plt.savefig(os.path.join(heatmap_folder, mode + f"_{z}-{next_z}_heatmap.png"), dpi=200)
        else:
            plt.savefig(os.path.join(heatmap_folder, f"cumulative_"+mode+"_heatmap.png"), dpi=200)

        if not is_cumul_mode: 
            cumul_mean += mean
            cumul_lower += lower
            cumul_upper += upper 

    if make_gifs:
        os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","normal"), exist_ok=True)
        output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps","normal", mode+"_heatmap_animation.gif")
        make_gif_from_pngs(heatmap_folder, output_gif_path, fps=fps)


def compact_sci(x, precision=2):
    """Makes python's default scientific notation display more compact."""
    s = f"{x:.{precision}e}"
    base, exp = s.split("e")
    return f"{base}e{int(exp)}"


def get_labels(mode):
    """Gets the graph labels for the heatmap plot."""
    if mode == "mass":
        xlabel = "Period [days]"
        ylabel = "Radius [$R_{⊕}$]"
    elif mode == "radius":
        ylabel = "Mass [$M_{⊕}$]"
        xlabel = "Period [days]"
    elif mode == "period":
        ylabel = "Mass [$M_{⊕}$]"
        xlabel = "Radius [$R_{⊕}$]"
    return xlabel, ylabel


def heatmap_prior_line_config(ax,z,next_z,x_array,y_array,mode):
    """Helper function which prepares the prior lines for graphing, then calls the graphing function."""
    def radius_given_density_mass(density,mass):
        return (((mass)*MEG)/((4/3)*np.pi*density))**(1/3) / RECM
        
    def mass_given_density_radius(density,radius):
        return ((4/3)*np.pi*density/MEG)*(radius * RECM)**3

    if mode == "mass":
        rho30_prior_upper = radius_given_density_mass(30,next_z)
        rho30_prior_lower = radius_given_density_mass(30,z)    
        rho10_prior_upper = radius_given_density_mass(10,next_z) 
        rho10_prior_lower = radius_given_density_mass(10,z)        
        rho001_prior_upper = radius_given_density_mass(0.01,next_z)
        rho001_prior_lower = radius_given_density_mass(0.01,z)

    elif mode == "radius":
        rho30_prior_upper = mass_given_density_radius(30,next_z)
        rho30_prior_lower = mass_given_density_radius(30,z)       
        rho10_prior_upper = mass_given_density_radius(10,next_z)
        rho10_prior_lower = mass_given_density_radius(10,z)        
        rho001_prior_upper = mass_given_density_radius(0.01,next_z)
        rho001_prior_lower = mass_given_density_radius(0.01,z)

    if (mode == "mass" or mode == "radius"):
        color_array = ["darkslategrey",'k','k',"darkslategrey"] if mode == "mass" else ['k',"darkslategrey","darkslategrey",'k']
        for colors, prior_line in zip(["dimgrey","dimgrey"]+color_array,[rho10_prior_lower,rho10_prior_upper,rho30_prior_upper,rho30_prior_lower,rho001_prior_upper,rho001_prior_lower]):
            heatmap_prior_lines(ax,x_array,y_array,prior_line,colors=colors)
    

def heatmap_prior_lines(ax,x_bins,y_bins,prior_line_y,colors='k'):
    """Helper function which plots the prior lines on the heatmaps."""
    if prior_line_y > np.max(y_bins):
        return 

    # Find the lower bin edge that encloses the prior line.
    bin_idx = np.searchsorted(y_bins, prior_line_y) - 1 

    # Make linear interpolation between bin edges.
    y_lower, y_upper = y_bins[bin_idx], y_bins[bin_idx + 1]
    frac = (prior_line_y - y_lower) / (y_upper - y_lower) 
    mapped_y = bin_idx + frac 

    # Plot the precise horizontal line.
    ax.hlines(y=mapped_y, xmin=0, xmax=len(x_bins)-1, colors=colors, linestyles='dashed')


def make_gif_from_pngs(input_dir, output_gif_path, fps=1,verbose=True):
    """Make gifs from the stacked heatmap sequences iterating through mass, period, or radius"""
    png_files = [f for f in os.listdir(input_dir) if f.endswith('.png')]
    
    file_numbers_dict = {} # Make dict with all the right png files.
    for file in png_files:
        m = re.search('\d+\.\d+',file)
        if m:
            value = float(m.group(0))
            file_numbers_dict[value] = file
        else:
            file_numbers_dict[9e99] = file
    
    if verbose: print(sorted(file_numbers_dict))
    images = []
    for key in sorted(file_numbers_dict): # Sort them, then create a gif out of it.
        image_path = os.path.join(input_dir, file_numbers_dict[key])
        image = Image.open(image_path)
        images.append(image)
        
    os.makedirs(os.path.dirname(output_gif_path), exist_ok=True)
    
    durations = np.ones(len(images))*1000/fps
    
    durations[-1] = 4 * 1000/fps
    
    durations = durations.astype(int).tolist()

    images[0].save(output_gif_path, save_all=True, append_images=images[1:], optimize=True, duration=durations, loop=0)

    if verbose: print(f"GIF saved to {output_gif_path}")
        
        
 ### some kind of best fit plot ??        
 ### residuals (best fit - data)

    
def trace_plot(voxel_id,results_folder):
    """Makes the trace plot for an individual voxel's Rmrp value."""
    voxel_grid = RPMGrid(radius_grid_array,period_grid_array,mass_grid_array)
    voxel = voxel_grid.find_voxel_by_id(voxel_id)

    trace_plot_folder = os.path.join(results_folder, "plots", "traces","basic_grid")
    os.makedirs(trace_plot_folder, exist_ok=True)
    sampler_backend_folder = results_folder + "/backend"
    
    filename = find_h5_file(voxel_id,sampler_backend_folder)
    file_path = os.path.join(sampler_backend_folder, filename)

    reader = emcee.backends.HDFBackend(file_path)

    samples = reader.get_chain()
    print("Chain shape:", samples.shape)
    n_steps, n_walkers, n_dim = samples.shape
    samples = np.array(samples)
    
    plt.figure(figsize=(10,5),dpi=150)
    for walker_data in samples.transpose(1,0,2):
        walker_data = np.squeeze(walker_data)
        plt.plot(np.linspace(0,n_steps,n_steps), walker_data)
    
    plt.xlabel("Step Number")
    plt.ylabel("$\mathcal{R}_{MRP}$")
    plt.suptitle("Trace Plot",fontsize=17)
    plt.title(f"voxel: {voxel.id_number}, R: {voxel.bottom_radius} - {voxel.top_radius}, "
            f"P: {voxel.bottom_period} - {voxel.top_period}, "
            f"M: {voxel.bottom_mass} - {voxel.top_mass})",fontsize=7)
    plt.savefig(trace_plot_folder+f"/{voxel_id}_trace.png", dpi=150)
    
    
def find_h5_file(voxel_id,sampler_backend_folder):
    """Finds the h5 file backend stored for a particular voxel."""
    voxel_id = str(voxel_id)
    h5_path = ""
    h5_files = [f for f in os.listdir(sampler_backend_folder) if f.endswith('.h5')]
    for file in h5_files:
        m = re.search("_"+voxel_id+"_",file)
        if m:
            h5_path = file
            break
    if not h5_path:
        return
    return h5_path


def corner_plot(voxel_id, results_folder):
    """Makes the corner plot for an individual voxel's Rmrp value."""
    voxel_grid = RPMGrid(radius_grid_array,period_grid_array,mass_grid_array)
    voxel = voxel_grid.find_voxel_by_id(voxel_id)

    corner_plot_folder = os.path.join(results_folder, "plots", "corners","basic_grid")
    os.makedirs(corner_plot_folder, exist_ok=True)
    sampler_backend_folder = results_folder + "/backend"
    
    filename = find_h5_file(voxel_id,sampler_backend_folder)
    file_path = os.path.join(sampler_backend_folder, filename)

    reader = emcee.backends.HDFBackend(file_path)

    samples = reader.get_chain()
    print("Chain shape:", samples.shape)
    n_steps, n_walkers, n_dim = samples.shape
    samples = np.array(samples)
    
    corner_plot = corner.corner(samples.reshape(-1,1),labels=["$\mathcal{R}_{MRP}$"])
    # plt.suptitle("         Corner Plot") ????
    plt.title(f"voxel: {voxel.id_number}, R: {voxel.bottom_radius} - {voxel.top_radius}, "
                f"P: {voxel.bottom_period} - {voxel.top_period}, "
                f"M: {voxel.bottom_mass} - {voxel.top_mass})",fontsize=7)
    
    corner_plot.savefig(corner_plot_folder+f"/{voxel_id}_corner.png",dpi=150)
        
        
def main(voxel_id,plottype):
    
    cwd = os.getcwd()

    # Find the plotprops path.
    if 'src' in cwd:
        plotprops_filename = "../runs/plotprops.txt"
    elif 'runs' in cwd:
        plotprops_filename = "plotprops.txt"
    elif 'results' in cwd:
        plotprops_filename = "plotprops.txt"
    else:
        print('you are not starting from a proper directory. you should run kg_plots.py from a src, runs, or a results directory.')
        sys.exit()
        
    # Get plotprops loaded in.
    getData = ReadJson(plotprops_filename)
    plotprops = getData.outProps()
    verbose = plotprops.get("verbose")
    # plottype = plotprops.get("plottype")
    input_data_filename = plotprops.get("input_data_filename")
    results_folder = plotprops.get("results_folder")
    make_gifs = plotprops.get("make_gifs")
    fps = plotprops.get("fps")
    heatmap_plot_type = plotprops.get("heatmap_plot_type")
    print("Plotting: ", plottype)
    
    voxel_grid = RPMGrid(radius_grid_array,period_grid_array,mass_grid_array)

    plot_all = plottype == "all"
    
    # Actually make the plots.
    if plot_all or plottype == "heatmap":
        heatmap_plot(voxel_grid,results_folder,mode=heatmap_plot_type,make_gifs=make_gifs,verbose=verbose,fps=fps)
             
    if plottype == "trace":
        assert voxel_id is not None, "You need to input the voxel you want to run trace plots on!"
        trace_plot(voxel_id,results_folder)
        
    if plottype == "corner":
        assert voxel_id is not None, "You need to input the voxel you want to run corner plots on!"
        corner_plot(voxel_id, results_folder)
        
    
if __name__ == "__main__":
   
    # Read the first argument as the voxel to plot.
    if len(sys.argv) > 1:
        voxel_id = int(sys.argv[1])
    else:
        print("Indicate which voxel to run kg_plots.py on!")
        sys.exit(1)

    # Read the second argument as the type of plot.
    if len(sys.argv) > 2:
        plottype = sys.argv[2]
        assert plottype == "trace" or plottype == "corner" or plottype == "heatmap", "Only valid plottypes are heatmap, trace, and corner."
    else:
        print("Indicate what type of plot to create. Valid plottypes are heatmap, trace, and corner.")
        sys.exit(1)
        
    main(voxel_id,plottype)