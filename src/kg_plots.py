"""
kg_plots.py
===========

Script that creates plots for the models of the KMDC datasest.

Controlled by the script found in /runs/plotprops.txt. Uses the 
base KMDC dataset for some plots, and will eventually use
the posteriors generated by the models to visualise the models.

Useage
------
Run from the command line:
  python kg_plots.py
  
Control via /runs/plotprops.txt (see that file for control options).

Author
------
Steven Blodgett <blodgett.steven.m@gmail.com>
Created on 2025-04-02
"""


import os
import sys
import commentjson as json
import re
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from PIL import Image

from kg_grid_boundary_arrays import radius_grid_array, period_grid_array, mass_grid_array
from kg_griddefiner import *


class ReadJson:
    """Read and store the contents of a Json file in a dict."""
    def __init__(self, filename):
        """Load the Json file."""
        print('reading in the plotprops.txt file')
        self.data = json.load(open(filename))
    def outProps(self):
        """Return the parsed Json dictionary."""
        return self.data

    
def heatmap_plot(rpm_grid,results_folder, make_gifs=True, verbose=False, fps=0.5, is_flat_density=False):
    """
    Plots sequences of heatmaps from the base KMDC, iterating on mass, radius, and period.
    
    The plots are stored in /results/plots/heatmaps and /results/plots/animations.
    
    Parameters
    ----------
    rpm_grid : RPMGrid
      A grid of radius-period-mass voxels (of class RPMVoxel).
    results_folder : str
      The pathway to Kepler Globals' results folder.
    make_gifs : bool, optional
      Whether the function should make a gif from its generated heatmaps (default is True).
    verbose : bool, optional
      Whether the function should produce print statements to track its progress (default is False).
    fps : float, optional
      What the frame rate for the gifs should be (default is 0.5).
    
    Returns
    -------
    None
    """
    if is_flat_density:
        heatmap_df = get_uniform_density_prior_df(rpm_grid)
    else:
        heatmap_df = get_heatmap_df(rpm_grid)
    make_mass_histograms(rpm_grid,results_folder,heatmap_df,make_gifs=make_gifs,verbose=verbose,fps=fps,is_flat_density=is_flat_density)
    make_radius_histograms(rpm_grid,results_folder,heatmap_df,make_gifs=make_gifs,verbose=verbose,fps=fps,is_flat_density=is_flat_density)
    make_period_histograms(rpm_grid,results_folder,heatmap_df,make_gifs=make_gifs,verbose=verbose,fps=fps,is_flat_density=is_flat_density)

    
def get_heatmap_df(rpm_grid):
    """Create a dataframe for the heatmap of only the relevant values."""
    heatmap_df = pd.DataFrame()

    for i in rpm_grid.voxel_array:
        for j in i:
            for k in j:
                df_selected = k.df[['R_pE', 'Period_days', 'M_pE', 'mass_divided_weights']]
                heatmap_df = pd.concat([heatmap_df, df_selected], ignore_index=True)

    return heatmap_df

def get_uniform_density_prior_df(rpm_grid):
    """Create a dataframe for the heatmap of the flat density prior."""
    heatmap_df = pd.DataFrame()
    
    for i in rpm_grid.voxel_array:
        for j in i:
            for k in j:
                df_selected = k.df[['R_pE', 'Period_days', 'M_pE', 'mass_divided_weights']]
                heatmap_df = pd.concat([heatmap_df, df_selected], ignore_index=True)
    
    
    M_30_priors = ((4/3)*np.pi*0.03/MEG)*(heatmap_df["R_pE"] * RECM)**3

    M_001_priors = ((4/3)*np.pi*0.01/MEG)*(heatmap_df["R_pE"] * RECM)**3 ### check upper limit and lower limit of contours
    
    heatmap_df["M_pE"] = np.random.uniform(M_001_priors,M_30_priors,len(heatmap_df["M_pE"]))
    return heatmap_df
    

def make_mass_histograms(rpm_grid,results_folder,histogram_df,make_gifs=True, verbose=False, fps=0.5, is_flat_density=False):
    """Make heatmaps iterating through mass."""
    if not is_flat_density: heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","normal","mass")
    if is_flat_density:  heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","flat_density","mass")
    os.makedirs(heatmap_folder, exist_ok=True)

    vmax = 0
    for i in range(len(rpm_grid.mass_grid_array) - 1): # Figure out what the max value of the histogram is going to be.
        lower_mass = rpm_grid.mass_grid_array[i]
        upper_mass = rpm_grid.mass_grid_array[i + 1]


        mass_filtered_df = histogram_df[(histogram_df["M_pE"] > lower_mass) & (histogram_df["M_pE"] <= upper_mass)]
        period_data = mass_filtered_df["Period_days"].values
        radius_data = mass_filtered_df["R_pE"].values
        weights = mass_filtered_df["mass_divided_weights"].values # I think I need to split this the other way too...

        hist, xedges, yedges = np.histogram2d(radius_data, period_data, 
                                              bins=[rpm_grid.radius_grid_array, rpm_grid.period_grid_array], 
                                              weights=weights)  
        
        hist /= 1000
        
        vmax = max(vmax, np.nanmax(hist))

    for i in range(len(rpm_grid.mass_grid_array) - 1):
        lower_mass = rpm_grid.mass_grid_array[i]
        upper_mass = rpm_grid.mass_grid_array[i + 1]

        mass_filtered_df = histogram_df[(histogram_df["M_pE"] > lower_mass) & (histogram_df["M_pE"] <= upper_mass)]
        period_data = mass_filtered_df["Period_days"].values
        radius_data = mass_filtered_df["R_pE"].values
        weights = mass_filtered_df["mass_divided_weights"].values 

        R_30_prior_upper = (((upper_mass)*MEG)/((4/3)*np.pi*30))**(1/3) / RECM
        R_30_prior_lower = (((lower_mass)*MEG)/((4/3)*np.pi*30))**(1/3) / RECM          


        R_001_prior_upper = (((upper_mass)*MEG)/((4/3)*np.pi*0.01))**(1/3) / RECM
        R_001_prior_lower = (((lower_mass)*MEG)/((4/3)*np.pi*0.01))**(1/3) / RECM

        hist, xedges, yedges = np.histogram2d(radius_data, period_data, 
                                              bins=[rpm_grid.radius_grid_array, rpm_grid.period_grid_array], 
                                              weights=weights)

        hist /= 1000
        
        plt.figure(figsize=(8, 6), dpi=200)

        ax = sns.heatmap(hist, annot=True, fmt=".4f", cbar=False, 
                         cmap=plt.cm.Spectral, vmin=0, vmax=vmax, annot_kws={"size": 5})
        #### put a line to denote where it's hard to detect planets?

        for prior_line in [R_30_prior_upper,R_30_prior_lower,R_001_prior_upper,R_001_prior_lower]:
            heatmap_prior_lines(ax,rpm_grid.period_grid_array,rpm_grid.radius_grid_array,prior_line)

        ax.set_xticks(np.arange(len(yedges)))
        ax.set_xticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in yedges], 
                            fontsize=5)

        ax.set_yticks(np.arange(len(xedges)))
        ax.set_yticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in xedges],rotation=90, fontsize=5)

        ax.invert_yaxis()

        plt.xlabel('Period [days]')
        plt.ylabel('Radius [$R_{Earth}$]')

        plt.suptitle("Occurrence-Weighted Fraction of PhoDyMM Kepler Systems", fontsize=15)
        if is_flat_density: plt.title(f"Flat Density, M={lower_mass}-{upper_mass}")
        if not is_flat_density: plt.title(f"M={lower_mass}-{upper_mass}")

        if not is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"M{lower_mass}-{upper_mass}_heatmap.png"), dpi=200)
        if is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"M{lower_mass}-{upper_mass}_flat_density_heatmap.png"), dpi=200)
        if verbose: 
            print(f"made M{lower_mass}-{upper_mass}_heatmap.png")
        plt.close()

    if make_gifs:
        if not is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","normal"), exist_ok=True)
        if is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","flat_density"), exist_ok=True)
        if not is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps","normal", "mass_heatmap_animation.gif")
        if is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps","flat_density", "mass_flat_density_heatmap_animation.gif")
        make_gif_from_pngs(heatmap_folder, output_gif_path, fps=fps)


def make_radius_histograms(rpm_grid,results_folder, histogram_df, make_gifs=True, verbose=False, fps=0.5, is_flat_density=False):
    """Make heatmaps iterating through radius."""
    if not is_flat_density: heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","normal","radius")
    if is_flat_density: heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","flat_density","radius")
    os.makedirs(heatmap_folder, exist_ok=True)

    vmax = 0
    for i in range(len(rpm_grid.radius_grid_array) - 1): # Figure out what the max value of the histogram is going to be.
        lower_radius = rpm_grid.radius_grid_array[i]
        upper_radius = rpm_grid.radius_grid_array[i + 1]


        radius_filtered_df = histogram_df[(histogram_df["R_pE"] > lower_radius) & (histogram_df["R_pE"] <= upper_radius)]
        period_data = radius_filtered_df["Period_days"].values
        mass_data = radius_filtered_df["M_pE"].values
        weights = radius_filtered_df["mass_divided_weights"].values

        hist, xedges, yedges = np.histogram2d(mass_data, period_data, 
                                              bins=[rpm_grid.mass_grid_array, rpm_grid.period_grid_array], 
                                              weights=weights)  
        hist /= 1000

        vmax = max(vmax, np.nanmax(hist))

    for i in range(len(rpm_grid.radius_grid_array) - 1):
        lower_radius = rpm_grid.radius_grid_array[i]
        upper_radius = rpm_grid.radius_grid_array[i + 1]

        radius_filtered_df = histogram_df[(histogram_df["R_pE"] > lower_radius) & (histogram_df["R_pE"] <= upper_radius)]
        period_data = radius_filtered_df["Period_days"].values
        mass_data = radius_filtered_df["M_pE"].values
        weights = radius_filtered_df["mass_divided_weights"].values

        M_30_prior_upper = ((4/3)*np.pi*30/MEG)*(upper_radius * RECM)**3
        M_30_prior_lower = ((4/3)*np.pi*30/MEG)*(lower_radius * RECM)**3         

        M_001_prior_upper = ((4/3)*np.pi*0.01/MEG)*(upper_radius * RECM)**3
        M_001_prior_lower = ((4/3)*np.pi*0.01/MEG)*(lower_radius * RECM)**3

        hist, xedges, yedges = np.histogram2d(mass_data, period_data, 
                                              bins=[rpm_grid.mass_grid_array, rpm_grid.period_grid_array], 
                                              weights=weights)

        hist /= 1000

        plt.figure(figsize=(8, 6), dpi=200)

        ax = sns.heatmap(hist, annot=True, fmt=".4f", cbar=False, 
                         cmap=plt.cm.Spectral, vmin=0, vmax=vmax, annot_kws={"size": 5})


        for prior_line in [M_30_prior_upper,M_30_prior_lower,M_001_prior_upper,M_001_prior_lower]:
            heatmap_prior_lines(ax,rpm_grid.period_grid_array,rpm_grid.mass_grid_array,prior_line)

        ax.set_xticks(np.arange(len(yedges)))
        ax.set_xticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in yedges], 
                            fontsize=5)

        ax.set_yticks(np.arange(len(xedges)))
        ax.set_yticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in xedges],rotation=90, fontsize=5)

        ax.invert_yaxis()

        plt.xlabel('Period [days]')
        plt.ylabel('Mass [$M_{Earth}$]')

        plt.suptitle("Occurrence-Weighted Fraction of PhoDyMM Kepler Systems", fontsize=15)
        if is_flat_density: plt.title(f"Flat Density,  R={lower_radius}-{upper_radius}")
        if not is_flat_density: plt.title(f"R={lower_radius}-{upper_radius}")

        if not is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"R{lower_radius}-{upper_radius}_heatmap.png"), dpi=200)
        if is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"R{lower_radius}-{upper_radius}_flat_density_heatmap.png"), dpi=200)
        if verbose: 
            print(f"made R{lower_radius}-{upper_radius}_heatmap.png")
        plt.close()

    if make_gifs:
        if not is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","normal"), exist_ok=True)
        if is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","flat_density"), exist_ok=True)
        if not is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps","normal", "radius_heatmap_animation.gif")
        if is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps","flat_density", "radius_flat_density_heatmap_animation.gif")
        make_gif_from_pngs(heatmap_folder, output_gif_path, fps=fps)      


def make_period_histograms(rpm_grid,results_folder, histogram_df, make_gifs=True, verbose=False, fps=0.5, is_flat_density=False):
    """Make heatmaps iterating through period"""
    if not is_flat_density: heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","normal","period")
    if is_flat_density: heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","flat_density","period")
    os.makedirs(heatmap_folder, exist_ok=True)

    vmax = 0
    for i in range(len(rpm_grid.period_grid_array) - 1): # Figure out what the max value of the histogram is going to be.
        lower_period = rpm_grid.period_grid_array[i]
        upper_period = rpm_grid.period_grid_array[i + 1]
        period_filtered_df = histogram_df[(histogram_df["Period_days"] > lower_period) & (histogram_df["Period_days"] <= upper_period)]
        radius_data = period_filtered_df["R_pE"].values
        mass_data = period_filtered_df["M_pE"].values
        weights = period_filtered_df["mass_divided_weights"].values

        hist, xedges, yedges = np.histogram2d(radius_data, mass_data,
                                              bins=[rpm_grid.radius_grid_array, rpm_grid.mass_grid_array], 
                                              weights=weights)  
        hist /= 1000
        vmax = max(vmax, np.nanmax(hist))

    for i in range(len(rpm_grid.period_grid_array) - 1):
        lower_period = rpm_grid.period_grid_array[i]
        upper_period = rpm_grid.period_grid_array[i + 1]

        period_filtered_df = histogram_df[(histogram_df["Period_days"] > lower_period) & (histogram_df["Period_days"] <= upper_period)]
        radius_data = period_filtered_df["R_pE"].values
        mass_data = period_filtered_df["M_pE"].values
        weights = period_filtered_df["mass_divided_weights"].values

        hist, xedges, yedges = np.histogram2d(radius_data, mass_data,
                                              bins=[rpm_grid.radius_grid_array, rpm_grid.mass_grid_array], 
                                              weights=weights)

        hist /= 1000
        plt.figure(figsize=(8, 6), dpi=200)

        ax = sns.heatmap(hist, annot=True, fmt=".4f", cbar=False, 
                         cmap=plt.cm.Spectral, vmin=0, vmax=vmax,annot_kws={"size": 5})

        ax.set_xticks(np.arange(len(yedges)))
        ax.set_xticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in yedges], 
                            fontsize=5)

        ax.set_yticks(np.arange(len(xedges)))
        ax.set_yticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in xedges],rotation=90, fontsize=5)

        ax.invert_yaxis()

        plt.ylabel('Radius [$R_{Earth}$]')
        plt.xlabel('Mass [$M_{Earth}$]')

        plt.suptitle("Occurrence-Weighted Fraction of PhoDyMM Kepler Systems With Given Mass vs Radius", fontsize=15)
        if not is_flat_density: plt.title(f"P={lower_period}-{upper_period}")
        if is_flat_density: plt.title(f"Flat Density, P={lower_period}-{upper_period}")

        if not is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"P{lower_period}-{upper_period}_heatmap.png"), dpi=200)
        if is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"P{lower_period}-{upper_period}_flat_density_heatmap.png"), dpi=200)
        if verbose: 
            print(f"made P{lower_period}-{upper_period}_heatmap.png")
        plt.close()

    if make_gifs:
        if not is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","normal"), exist_ok=True)
        if is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","flat_density"), exist_ok=True)
        if not is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps", "normal", "period_heatmap_animation.gif")
        if is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations", "heatmaps","flat_density","period_flat_density_heatmap_animation.gif")
        make_gif_from_pngs(heatmap_folder, output_gif_path, fps=fps)   


def heatmap_prior_lines(ax,x_bins,y_bins,prior_line_y):
    """Helps to plot the prior lines on the heatmaps."""
    if prior_line_y > np.max(y_bins):
        return 

    # Find the lower bin edge that encloses the prior line.
    bin_idx = np.searchsorted(y_bins, prior_line_y) - 1 

    # Make linear interpolation between bin edges.
    y_lower, y_upper = y_bins[bin_idx], y_bins[bin_idx + 1]
    frac = (prior_line_y - y_lower) / (y_upper - y_lower) 
    mapped_y = bin_idx + frac 

    # Plot the precise horizontal line.
    ax.hlines(y=mapped_y, xmin=0, xmax=len(x_bins)-1, colors='k', linestyles='dashed')


def make_gif_from_pngs(input_dir, output_gif_path, fps=1,verbose=True):
    """Make gifs from the stacked heatmap sequences iterating through mass, period, or radius"""
    png_files = [f for f in os.listdir(input_dir) if f.endswith('.png')]
    
    file_numbers_dict = {} # Make dict with all the right png files.
    for file in png_files:
        m = re.search('\d+\.\d+',file)
        value = float(m.group(0))
        file_numbers_dict[value] = file
    
    images = []
    for key in sorted(file_numbers_dict): # Sort them, then create a gif out of it.
        image_path = os.path.join(input_dir, file_numbers_dict[key])
        image = Image.open(image_path)
        images.append(image)
        
    os.makedirs(os.path.dirname(output_gif_path), exist_ok=True)

    images[0].save(output_gif_path, save_all=True, append_images=images[1:], optimize=True, duration=1000/fps, loop=0)

    if verbose: print(f"GIF saved to {output_gif_path}")
        
        
 ### some kind of best fit plot        
 ### residuals (best fit - data)       
    
 ### add a plot that sums along all the voxels in a column and displays it at the end as like a summed up heatmap thing 
        
        
def main():
    
    cwd = os.getcwd()

    # Find the plotprops path.
    if 'src' in cwd:
        plotprops_filename = "../runs/plotprops.txt"
    elif 'runs' in cwd:
        plotprops_filename = "plotprops.txt"
    elif 'results' in cwd:
        plotprops_filename = "plotprops.txt"
    else:
        print('you are not starting from a proper directory. you should run kg_run.py from a src, runs, or a results directory.')
        sys.exit()
        
    # Get plotprops loaded in.
    getData = ReadJson(plotprops_filename)
    plotprops = getData.outProps()
    verbose = plotprops.get("verbose")
    plottype = plotprops.get("plottype")
    input_data_filename = plotprops.get("input_data_filename")
    results_folder = plotprops.get("results_folder")
    make_gifs = plotprops.get("make_gifs")
    fps = plotprops.get("fps")
    print(plottype, type(plottype))
    
    voxel_grid = RPMGrid(radius_grid_array,period_grid_array,mass_grid_array)

    df = pd.read_csv(input_data_filename)
    voxel_grid.setup_dataframes(df.columns)
    voxel_grid.add_data(df)
    voxel_grid.make_mass_divided_weights()
    
    plot_all = plottype == "all"
    
    # Actually make the plots.
    if plot_all or plottype == "heatmap":
        heatmap_plot(voxel_grid,'../results',make_gifs=make_gifs,verbose=verbose,fps=fps)
        
    if plot_all or plottype == "heatmap_flat_density":
        heatmap_plot(voxel_grid,'../results',make_gifs=make_gifs,verbose=verbose,fps=fps,is_flat_density=True)
    
    
if __name__ == "__main__":
    main()