"""
kg_plots.py
===========

Script that creates plots for the models of the KMDC datasest.

Controlled by the script found in /runs/plotprops.txt. 
Uses the base KMDC dataset for some plots, and uses the 
posteriors generated by the models to visualise the models.

Useage
------
Run from the command line:
  python kg_plots.py voxel_id plottype

Parameters
----------
voxel_id : int
  The id number of the voxel you want to graph.
plottype : str
  The kind of plot you want to create.

Additional script control is given via /runs/plotprops.txt (see that file for control options).

Author
------
Steven Blodgett <blodgett.steven.m@gmail.com>
Created on 2025-04-02
"""

import corner
import emcee
import h5py
import os
import sys
import commentjson as json
import re
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap, BoundaryNorm
import matplotlib.ticker as ticker

from PIL import Image

from kg_grid_boundary_arrays import radius_grid_array, period_grid_array, mass_grid_array
from kg_griddefiner import RPMGrid, RPMVoxel
from kg_constants import *


class ReadJson:
    """Read and store the contents of a Json file in a dict."""
    def __init__(self, filename):
        """Load the Json file."""
        print('reading in the plotprops.txt file')
        self.data = json.load(open(filename))
    def outProps(self):
        """Return the parsed Json dictionary."""
        return self.data

    
def heatmap_plot(rpm_grid,results_folder,nburnin,mode="all", make_gifs=True, verbose=False, is_plot_ids=False, fps=0.5,backend_path="../results/backend"):
    """
    Plots sequences of heatmaps from the base KMDC, iterating on mass, radius, and period.
    
    The plots are stored in /results/plots/heatmaps and /results/plots/animations.
    
    Parameters
    ----------
    rpm_grid : RPMGrid
      A grid of radius-period-mass voxels (of class RPMVoxel).
    results_folder : str
      The pathway to Kepler Globals' results folder.
    mode : str, optional
      Which kind of heatmap should be plotted. Default is 'all', which plots all three types.
    make_gifs : bool, optional
      Whether the function should make a gif from its generated heatmaps (default is True).
    verbose : bool, optional
      Whether the function should produce print statements to track its progress (default is False).
    fps : float, optional
      What the frame rate for the gifs should be (default is 0.5).
    
    Returns
    -------
    None
    """
    if mode == "all" or mode == "mass":
        make_histograms(rpm_grid,results_folder,nburnin,mode="mass",make_gifs=make_gifs,verbose=verbose, is_plot_ids=is_plot_ids, fps=fps,backend_path=backend_path)
    if mode == "all" or mode == "period":
        make_histograms(rpm_grid,results_folder,nburnin,mode="period",make_gifs=make_gifs,verbose=verbose, is_plot_ids=is_plot_ids, fps=fps,backend_path=backend_path)
    if mode == "all" or mode == "radius":
        make_histograms(rpm_grid,results_folder,nburnin,mode="radius",make_gifs=make_gifs,verbose=verbose, is_plot_ids=is_plot_ids,fps=fps,backend_path=backend_path)


def get_arrays(mode):
    """Load the correct arrays for the heatmap plots."""
    if mode == "mass":
        x_array = period_grid_array
        y_array = radius_grid_array
        z_array = mass_grid_array
        search_dict = {"z":7,"z_next":8,"x":3,"y":5}
    elif mode == "period":
        x_array = radius_grid_array
        y_array = mass_grid_array
        z_array = period_grid_array
        search_dict = {"z":5,"z_next":6,"x":7,"y":3}
    elif mode == "radius":
        x_array = period_grid_array
        y_array = mass_grid_array
        z_array = radius_grid_array
        search_dict = {"z":3,"z_next":4,"x":7,"y":5}
    return x_array, y_array, z_array, search_dict


def make_histograms(rpm_grid, results_folder,nburnin, mode, make_gifs=True, verbose=False, is_plot_ids=False, fps=0.5,backend_path="../results/backend"): ######## tidy up this script a lot
    """This function needs to be cut down to size..."""

    assert mode == "mass" or mode == "period" or mode == "radius", "heatmaps iterate over mass, period, or radius"
    
    x_array, y_array, z_array, search_dict = get_arrays(mode)

    heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","normal",mode)
    os.makedirs(heatmap_folder, exist_ok=True)

    Rmrps = rpm_grid.get_Rmrps(nburnin,backend_path)

    all_means = Rmrps[:,0]
    vmax = np.max(all_means*100) # Express Rmrp in a percentage.
    vmin = np.min(all_means[all_means>0]*100)

    cumul_mean = np.zeros((len(y_array)-1,len(x_array)-1))
    cumul_lower = np.zeros((len(y_array)-1,len(x_array)-1))
    cumul_upper = np.zeros((len(y_array)-1,len(x_array)-1))
    is_cumul_mode = False
    for i, z in enumerate(z_array):
        
        if i == len(z_array)-1:
            is_cumul_mode = True
        if not is_cumul_mode: 
            next_z = z_array[i+1]

            mean = np.empty((len(y_array)-1,len(x_array)-1))
            lower = np.empty((len(y_array)-1,len(x_array)-1))
            upper = np.empty((len(y_array)-1,len(x_array)-1))
            ids = np.empty((len(y_array)-1,len(x_array)-1))
            annot = np.empty((len(y_array)-1, len(x_array)-1), dtype=object)

            for voxel in Rmrps:
                
                if voxel[search_dict["z"]] == z and voxel[search_dict["z_next"]] == next_z:
                    
                    x_idx = np.searchsorted(y_array, voxel[search_dict["x"]],side='right')-1
                    y_idx = np.searchsorted(x_array, voxel[search_dict["y"]],side='right')-1
                    
                    voxel[0] *= 100
                    voxel[1] *= 100
                    voxel[2] *= 100

                    mean[x_idx,y_idx] = voxel[0]
                    lower[x_idx,y_idx] = voxel[1]
                    upper[x_idx,y_idx] = voxel[2]
                    ids[x_idx,y_idx] = voxel[9]
                    if voxel[0] == 0:
                        annot[x_idx,y_idx] = f"{voxel[0]:.1f}$^{{+{voxel[2]:.1f}}}_{{-{voxel[1]:.1f}}}$%"
                    elif voxel[0] < 1e-2 and voxel[0] > 1e-3:
                        annot[x_idx,y_idx] = f"{voxel[0]:.3f}$^{{+{voxel[2]:.3f}}}_{{-{voxel[1]:.3f}}}$%"
                    elif voxel[0] < 1e-3:
                        annot[x_idx,y_idx] = f"{compact_sci(voxel[0])}$^{{+{compact_sci(voxel[2],1)}}}_{{-{compact_sci(voxel[1],1)}}}$%"
                    else:
                        annot[x_idx,y_idx] = f"{voxel[0]:.2f}$^{{+{voxel[2]:.3f}}}_{{-{voxel[1]:.3f}}}$%"

        if is_cumul_mode:
            mean = cumul_mean
            upper = cumul_upper
            lower = cumul_lower
            for row_idx, row in enumerate(mean):
                for col_idx, voxel_mean in enumerate(row):
                    if voxel_mean == 0:
                        annot[row_idx,col_idx] = f"{voxel_mean:.1f}$^{{+{upper[row_idx,col_idx]:.1f}}}_{{-{lower[row_idx,col_idx]:.1f}}}$%"
                    elif voxel[0] < 1e-2 and voxel[0] > 1e-3:
                        annot[row_idx,col_idx] = f"{voxel_mean:.3f}$^{{+{upper[row_idx,col_idx]:.3f}}}_{{-{lower[row_idx,col_idx]:.3f}}}$%"
                    elif voxel_mean < 1e-3:
                        annot[row_idx,col_idx] = f"{compact_sci(voxel_mean)}$^{{+{compact_sci(upper[row_idx,col_idx],1)}}}_{{-{compact_sci(lower[row_idx,col_idx],1)}}}$%"
                    else:
                        annot[row_idx,col_idx] = f"{voxel_mean:.2f}$^{{+{upper[row_idx,col_idx]:.3f}}}_{{-{lower[row_idx,col_idx]:.3f}}}$%"

        
        # Create a cubehelix palette

        cubehelix = sns.cubehelix_palette(start=2,rot=-1.4,n_colors=1000,light=.74,dark=0.4,reverse=False)
        # Prepend gray for zero values
        colors = [(0.6, 0.6, 0.6)] + cubehelix
        cmap = ListedColormap(colors)

        # Handle vmax if in cumulative mode
        if is_cumul_mode:
            vmax = np.max(mean[mean > 0])  # Exclude zeros for log spacing
            vmin = np.min(mean[mean>0])
        print("vmax: ",vmax)
        print("vmin: ",vmin)

        # Create boundaries:
        n_bins = len(colors) - 1  # excluding the zero bin
        log_boundaries = np.logspace(np.log10(np.nextafter(vmin, 0)), np.log10(vmax), n_bins)
        boundaries = [0] + list(log_boundaries)
        norm = BoundaryNorm(boundaries, len(colors))

        plt.figure(figsize=(10, 8),dpi=250,facecolor="#000034")
        ax = sns.heatmap(mean, annot=annot, fmt='', cmap=cmap, norm=norm,#vmin=0.0, vmax=vmax,
                        cbar=False,annot_kws={"size":6.7,"color": "white","weight": "bold" })

        if not is_cumul_mode and is_plot_ids:
            for i in range(mean.shape[0]):      # rows (y)
                for j in range(mean.shape[1]):  # columns (x)
                    # Calculate the id number for this cell (replace with your actual logic if needed)
                    id_number = int(ids[i,j])  # Or however you want to tag it

                    # Place in upper left: x=j, y=i, with a small offset
                    ax.text(j + 0.02, i + 0.15, id_number, color='white', fontsize=3, ha='left', va='top', alpha=0.5)



        xedges = np.array(x_array)
        yedges = np.array(y_array)
        
        if not is_cumul_mode:
            heatmap_prior_line_config(ax,z,next_z,x_array,y_array,mode)


        xtick_positions = np.arange(len(xedges))
        xtick_labels = [f"{x:.2f}" if x < 1e5 else f"{x:.2e}" for x in xedges]
        ax.set_xticks(xtick_positions)
        ax.set_xticklabels(xtick_labels, rotation=45, fontsize=8,color="white")

        # Y-axis: radius bin edges
        ytick_positions = np.arange(len(yedges))
        ytick_labels = [f"{y:.2f}" if y < 1e5 else f"{y:.2e}" for y in yedges]
        ax.set_yticks(ytick_positions)
        ax.set_yticklabels(ytick_labels, rotation=0, fontsize=8,color="white")

        # Flip y-axis so smaller radii are on bottom
        ax.invert_yaxis()

        xlabel, ylabel = get_labels(mode)
        plt.grid()
        plt.xlabel(xlabel,color="white",fontsize=12)
        plt.ylabel(ylabel,color="white",fontsize=12)
        plt.suptitle("$\mathcal{R}_{MRP}$ Heatmap", fontsize=25,color="white")
        if not is_cumul_mode:
            plt.title(mode+f" {z}-{next_z}",color="white")
        else:
            plt.title(mode +" (cumulative)",color="white")
        plt.tight_layout()
        if not is_cumul_mode: 
            plt.savefig(os.path.join(heatmap_folder, mode + f"_{z}-{next_z}_heatmap.png"), dpi=200)
        else:
            plt.savefig(os.path.join(heatmap_folder, f"cumulative_"+mode+"_heatmap.png"), dpi=200)
        plt.close()
        if not is_cumul_mode: 
            cumul_mean += mean
            cumul_lower += lower
            cumul_upper += upper

    if make_gifs:
        os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","normal"), exist_ok=True)
        output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps","normal", mode+"_heatmap_animation.gif")
        make_gif_from_pngs(heatmap_folder, output_gif_path, fps=fps)


def compact_sci(x, precision=2):
    """Makes python's default scientific notation display more compact."""
    s = f"{x:.{precision}e}"
    base, exp = s.split("e")
    return f"{base}e{int(exp)}"


def get_labels(mode):
    """Gets the graph labels for the heatmap plot."""
    if mode == "mass":
        xlabel = "Period [days]"
        ylabel = "Radius [$R_{⊕}$]"
    elif mode == "radius":
        ylabel = "Mass [$M_{⊕}$]"
        xlabel = "Period [days]"
    elif mode == "period":
        ylabel = "Mass [$M_{⊕}$]"
        xlabel = "Radius [$R_{⊕}$]"
    else:
        raise ValueError("Invalid mode. Choose 'mass', 'radius', or 'period'.")
    return xlabel, ylabel


def heatmap_prior_line_config(ax,z,next_z,x_array,y_array,mode):
    """Helper function which prepares the prior lines for graphing, then calls the graphing function."""
    def radius_given_density_mass(density,mass):
        return (((mass)*MEG)/((4/3)*np.pi*density))**(1/3) / RECM
        
    def mass_given_density_radius(density,radius):
        return ((4/3)*np.pi*density/MEG)*(radius * RECM)**3

    if mode == "mass":
        rho30_prior_upper = radius_given_density_mass(30,next_z)
        rho30_prior_lower = radius_given_density_mass(30,z)    
        rho10_prior_upper = radius_given_density_mass(10,next_z) 
        rho10_prior_lower = radius_given_density_mass(10,z)        
        rho001_prior_upper = radius_given_density_mass(0.01,next_z)
        rho001_prior_lower = radius_given_density_mass(0.01,z)
        rho55_earth_upper = radius_given_density_mass(5.5,next_z)
        rho55_earth_lower = radius_given_density_mass(5.5,z)

    elif mode == "radius":
        rho30_prior_upper = mass_given_density_radius(30,next_z)
        rho30_prior_lower = mass_given_density_radius(30,z)       
        rho10_prior_upper = mass_given_density_radius(10,next_z)
        rho10_prior_lower = mass_given_density_radius(10,z)        
        rho001_prior_upper = mass_given_density_radius(0.01,next_z)
        rho001_prior_lower = mass_given_density_radius(0.01,z)
        rho55_earth_upper = mass_given_density_radius(5.5,next_z)
        rho55_earth_lower = mass_given_density_radius(5.5,z)

    if (mode == "mass" or mode == "radius"):
        color_array = ["darkslategrey",'k','k',"darkslategrey"] if mode == "mass" else ['k',"darkslategrey","darkslategrey",'k']
        for colors, prior_line in zip(["aqua","aqua","dimgrey","dimgrey"]+color_array,[rho55_earth_lower,rho55_earth_upper,rho10_prior_lower,rho10_prior_upper,rho30_prior_upper,rho30_prior_lower,rho001_prior_upper,rho001_prior_lower]):
            alpha = 0.2 if colors == "aqua" else 0.7
            heatmap_prior_lines(ax,x_array,y_array,prior_line,colors=colors,alpha=alpha)
    

def heatmap_prior_lines(ax,x_bins,y_bins,prior_line_y,colors='k',alpha=0.7):
    """Helper function which plots the prior lines on the heatmaps."""
    if prior_line_y > np.max(y_bins):
        return 

    # Find the lower bin edge that encloses the prior line.
    bin_idx = np.searchsorted(y_bins, prior_line_y) - 1 

    # Make linear interpolation between bin edges.
    y_lower, y_upper = y_bins[bin_idx], y_bins[bin_idx + 1]
    frac = (prior_line_y - y_lower) / (y_upper - y_lower) 
    mapped_y = bin_idx + frac 

    # Plot the precise horizontal line.
    ax.hlines(y=mapped_y, xmin=0, xmax=len(x_bins)-1, colors=colors, linestyles='dashed',alpha=alpha)


def make_gif_from_pngs(input_dir, output_gif_path, fps=1,verbose=True,residual_iter=None):
    """Make gifs from the stacked heatmap sequences iterating through mass, period, or radius"""
    if residual_iter is None:
        png_files = [f for f in os.listdir(input_dir) if f.endswith('.png')]
    else:
        png_files = [f for f in os.listdir(input_dir) if f.endswith('.png') and f"{residual_iter}_residual" in f]
    
    file_numbers_dict = {} # Make dict with all the right png files.
    for file in png_files:

        if residual_iter is None:
            m = re.search('\d+\.\d+',file)
        else:
            m = re.search(f"\d+\.\d+_{residual_iter}",file)

        if m:
            m = m.group(0)
            if residual_iter is not None:
                m = m.split("_")[0]
            value = float(m)
            file_numbers_dict[value] = file
        else:
            file_numbers_dict[9e99] = file
    
    if verbose: print(sorted(file_numbers_dict))
    images = []
    for key in sorted(file_numbers_dict): # Sort them, then create a gif out of it.
        image_path = os.path.join(input_dir, file_numbers_dict[key])
        image = Image.open(image_path)
        images.append(image)
        
    os.makedirs(os.path.dirname(output_gif_path), exist_ok=True)
    
    durations = np.ones(len(images))*1000/fps
    
    durations[-1] = 4 * 1000/fps
    
    durations = durations.astype(int).tolist()

    images[0].save(output_gif_path, save_all=True, append_images=images[1:], optimize=True, duration=durations, loop=0)

    if verbose: print(f"GIF saved to {output_gif_path}")
        
        
 ### some kind of best fit plot ??        
 ### residuals (best fit - data)

    
def trace_plot(voxel_id,results_folder,nburnin):
    """Makes the trace plot for an individual voxel's Rmrp value."""
    voxel_grid = RPMGrid(radius_grid_array,period_grid_array,mass_grid_array)
    voxel = voxel_grid.find_voxel_by_id(voxel_id)

    trace_plot_folder = os.path.join(results_folder, "plots", "traces","basic_grid")
    os.makedirs(trace_plot_folder, exist_ok=True)
    sampler_backend_folder = results_folder + "/backend"
    
    filename = find_h5_file(voxel_id,sampler_backend_folder)
    file_path = os.path.join(sampler_backend_folder, filename)

    reader = emcee.backends.HDFBackend(file_path)

    samples = reader.get_chain()
    samples = samples[nburnin:,:,:]

    print("Chain shape:", samples.shape)
    n_steps, n_walkers, n_dim = samples.shape
    samples = np.array(samples)
    
    plt.figure(figsize=(10,5),dpi=150)
    for walker_data in samples.transpose(1,0,2):
        walker_data = np.squeeze(walker_data)
        plt.plot(np.linspace(0,n_steps,n_steps), walker_data)
    
    plt.minorticks_on()
    plt.grid()
    plt.xlabel("Step Number")
    plt.ylabel("$\mathcal{R}_{MRP}$")
    plt.suptitle("Trace Plot",fontsize=17)
    plt.title(f"voxel: {voxel.id_number}, R: {voxel.bottom_radius} - {voxel.top_radius}, "
            f"P: {voxel.bottom_period} - {voxel.top_period}, "
            f"M: {voxel.bottom_mass} - {voxel.top_mass})",fontsize=7)
    plt.savefig(trace_plot_folder+f"/{voxel_id}_trace.png", dpi=150)
    
    
def find_h5_file(voxel_id,sampler_backend_folder):
    """Finds the h5 file backend stored for a particular voxel."""
    voxel_id = str(voxel_id)
    h5_path = ""
    h5_files = [f for f in os.listdir(sampler_backend_folder) if f.endswith('.h5')]
    for file in h5_files:
        m = re.search("_"+voxel_id+"_",file)
        if m:
            h5_path = file
            break
    if not h5_path:
        return
    return h5_path


def corner_plot(voxel_id, results_folder, nburnin):
    """Makes the corner plot for an individual voxel's Rmrp value."""
    voxel_grid = RPMGrid(radius_grid_array,period_grid_array,mass_grid_array)
    voxel = voxel_grid.find_voxel_by_id(voxel_id)

    corner_plot_folder = os.path.join(results_folder, "plots", "corners","basic_grid")
    os.makedirs(corner_plot_folder, exist_ok=True)
    sampler_backend_folder = results_folder + "/backend"
    
    filename = find_h5_file(voxel_id,sampler_backend_folder)
    file_path = os.path.join(sampler_backend_folder, filename)

    reader = emcee.backends.HDFBackend(file_path)

    samples = reader.get_chain()
    samples = samples[nburnin:,:,:]

    print("Chain shape:", samples.shape)

    n_steps, n_walkers, n_dim = samples.shape
    samples = np.array(samples)
    
    corner_plot = corner.corner(samples.reshape(-1,1),labels=["$\mathcal{R}_{MRP}$"])
    # plt.suptitle("         Corner Plot") ????
    plt.title(f"voxel: {voxel.id_number}, R: {voxel.bottom_radius} - {voxel.top_radius}, "
                f"P: {voxel.bottom_period} - {voxel.top_period}, "
                f"M: {voxel.bottom_mass} - {voxel.top_mass})",fontsize=7)
    
    corner_plot.savefig(corner_plot_folder+f"/{voxel_id}_corner.png",dpi=150)
        

def residual_plot(rpm_grid,results_folder,nburnin,mode="all",verbose=False,fps=0.5,backend_path="../results/backend",make_gifs=True):
    """
    Makes the residual plot for an individual voxel's Rmrp value.
    
    Parameters
    ----------
    rpm_grid : RPMGrid
      A grid of radius-period-mass voxels (of class RPMVoxel).
    results_folder : str
      The pathway to Kepler Globals' results folder.
    nburnin : int
      The number of burn-in steps to skip in the MCMC chain.
    mode : str, optional
      The type of residual plot to create. Default is 'all', which plots all three types.
    verbose : bool, optional
      Whether the function should produce print statements to track its progress (default is False).
    fps : float, optional
      What the frame rate for the gifs should be (default is 0.5).
    
    Returns
    -------
    None
    """

    if mode == "all" or mode == "mass":
        make_residuals(rpm_grid,results_folder,nburnin,mode="mass",verbose=verbose,fps=fps,backend_path=backend_path,make_gifs=make_gifs)
        make_residuals(rpm_grid,results_folder,nburnin,mode="mass",verbose=verbose,fps=fps,backend_path=backend_path,switch=True,make_gifs=make_gifs)

    if mode == "all" or mode == "period":
        make_residuals(rpm_grid,results_folder,nburnin,mode="period",verbose=verbose,fps=fps,backend_path=backend_path,make_gifs=make_gifs)
        make_residuals(rpm_grid,results_folder,nburnin,mode="period",verbose=verbose,fps=fps,backend_path=backend_path,switch=True,make_gifs=make_gifs)
    if mode == "all" or mode == "radius":
        make_residuals(rpm_grid,results_folder,nburnin,mode="radius",verbose=verbose,fps=fps,backend_path=backend_path,make_gifs=make_gifs)
        make_residuals(rpm_grid,results_folder,nburnin,mode="radius",verbose=verbose,fps=fps,backend_path=backend_path,switch=True,make_gifs=make_gifs)

def make_residuals(rpm_grid,results_folder,nburnin,mode="mass",verbose=False,fps=0.5,backend_path="../results/backend",switch=False,make_gifs=True):
    """
    Makes the residuals for a given voxel.
    
    Parameters
    ----------
    rpm_grid : RPMGrid
      A grid of radius-period-mass voxels (of class RPMVoxel).
    results_folder : str
      The pathway to Kepler Globals' results folder.
    nburnin : int
      The number of burn-in steps to skip in the MCMC chain.bin_edges
    mode : str, optional
      The type of residual plot to create. Default is 'mass'.
    verbose : bool, optional
      Whether the function should produce print statements to track its progress (default is False).
    fps : float, optional
      What the frame rate for the gifs should be (default is 0.5).
    
    Returns
    -------
    None
    """
    
    assert mode == "mass" or mode == "period" or mode == "radius", "residuals iterate over mass, period, or radius"
    
    if not switch:
        x_array, y_array, z_array, search_dict = get_arrays(mode)
    else:
        y_array, x_array, z_array, search_dict = get_arrays(mode)

    residual_folder = os.path.join(results_folder, "plots", "residuals","normal",mode)
    os.makedirs(residual_folder, exist_ok=True)

    Rmrps = rpm_grid.get_Rmrps(nburnin,backend_path)

    cumul_mean = np.zeros((len(y_array)-1))
    cumul_lower = np.zeros((len(y_array)-1))
    cumul_upper = np.zeros((len(y_array)-1))
    is_cumul_mode = False
    print("x_array: ", x_array)
    print("y_array: ", y_array)

    over_dimension = None

    for i, z in enumerate(z_array):
        
        if i == len(z_array)-1:
            is_cumul_mode = True
            
        if not is_cumul_mode: 
            next_z = z_array[i+1]

            mean = np.zeros((len(y_array)-1))
            lower = np.zeros((len(y_array)-1))
            upper = np.zeros((len(y_array)-1))

            for voxel in Rmrps:
            #   print("nextz_comp: ",voxel[search_dict["z_next"]], next_z)

                if voxel[search_dict["z"]] == z and voxel[search_dict["z_next"]] == next_z:
                    dict_key = "x" if not switch else "y"
                    idx = np.searchsorted(y_array, voxel[search_dict[dict_key]],side='right')-1
                    # print("y_idx: ",y_idx)5
                    # print("voxel[0]: ",voxel[0])
                    mean[idx] += voxel[0] * 100
                    lower[idx] += voxel[1] * 100
                    upper[idx] += voxel[2] * 100
                    # input("mean: "+str(mean)+" lower: "+str(lower)+" upper: "+str(upper))
                    
        if is_cumul_mode:
            mean = cumul_mean
            upper = cumul_upper
            lower = cumul_lower
            
        bins = range(len(mean))  # len(mean) = N bins
        bin_edges = y_array      # N+1 edges for N bins

        plt.figure()
        plt.bar(bins, mean, width=1, align='edge', alpha=0.7, color='skyblue',zorder=2)

        yerr = [lower, upper]

        # Add error bars at center of each bin
        bin_centers = np.array(bins) + 0.5  # center of each bar if width=1
        plt.errorbar(
            bin_centers,
            mean,
            yerr=yerr,
            fmt='none',
            color='black',
            ecolor='gray',
            elinewidth=0.75,
            capsize=3,
            label='$1\sigma$ Error Bars'
        )

        plt.grid(axis='y', linestyle='--', alpha=0.7)

        if not switch:
            xlabel, ylabel = get_labels(mode) 
        else:
            ylabel, xlabel = get_labels(mode)

        if not is_cumul_mode: 
            plt.title(f'Residuals for {mode} {z}-{next_z}')
        else: 
            plt.title(f'Residuals for {mode} (cumulative)')
        # Use all N+1 bin edges as tick labels
        plt.xticks(
            ticks=np.arange(len(bin_edges)),  # 0 to N
            labels=[f"{v:.2f}" if v < 1e4 else f"{v:.2e}" for v in bin_edges],
            rotation=45
        )

        plt.xlabel(ylabel)
        plt.ylabel('$\mathcal{R}_{MRP}$')
        plt.tight_layout()
        plt.show()

        over_dimension = ylabel.split()[0].lower()

        if not is_cumul_mode: 
            plt.savefig(os.path.join(residual_folder, mode + f"_{z}-{next_z}_{over_dimension}_residual.png"), dpi=200)
        else:
            plt.savefig(os.path.join(residual_folder, f"cumulative_"+mode+f"_{over_dimension}_residual.png"), dpi=200)
        plt.close()  # Close the plot to free memory
        # input()
        if not is_cumul_mode: 
            cumul_mean += mean
            cumul_lower += lower
            cumul_upper += upper

    if make_gifs:
        os.makedirs(os.path.join(results_folder, "plots", "animations","residuals","normal"), exist_ok=True)
        output_gif_path = os.path.join(results_folder, "plots", "animations","residuals","normal", mode+f"_over_{over_dimension}_residual_animation.gif")
        make_gif_from_pngs(residual_folder, output_gif_path, fps=fps, residual_iter=over_dimension)

    

    
def main(voxel_id,plottype):
    
    cwd = os.getcwd()

    # Find the plotprops path.
    if 'src' in cwd:
        plotprops_filename = "../runs/plotprops.txt"
    elif 'runs' in cwd:
        plotprops_filename = "plotprops.txt"
    elif 'results' in cwd:
        plotprops_filename = "plotprops.txt"
    else:
        print('you are not starting from a proper directory. you should run kg_plots.py from a src, runs, or a results directory.')
        sys.exit()
        
    # Get plotprops loaded in.
    getData = ReadJson(plotprops_filename)
    plotprops = getData.outProps()
    nburnin = plotprops.get("nburnin")
    verbose = plotprops.get("verbose")
    # plottype = plotprops.get("plottype")
    input_data_filename = plotprops.get("input_data_filename")
    results_folder = plotprops.get("results_folder")
    backend_path = plotprops.get("backend_path")
    make_gifs = plotprops.get("make_gifs")
    fps = plotprops.get("fps")
    is_plot_ids = plotprops.get("is_plot_ids")
    heatmap_plot_type = plotprops.get("heatmap_plot_type")
    residual_plot_type = plotprops.get("residual_plot_type")
    print("Plotting: ", plottype)
    
    voxel_grid = RPMGrid(radius_grid_array,period_grid_array,mass_grid_array)
# Default to False if not specified
    # Actually make the plots.
    if plottype == "residual":
        residual_plot(voxel_grid,results_folder,nburnin,mode=residual_plot_type,verbose=verbose,fps=fps,backend_path=backend_path,make_gifs=make_gifs)
    
    if plottype == "heatmap":
        heatmap_plot(voxel_grid,results_folder,nburnin,mode=heatmap_plot_type,make_gifs=make_gifs,verbose=verbose,is_plot_ids=is_plot_ids,fps=fps,backend_path=backend_path)
             
    if plottype == "trace":
        assert voxel_id is not None, "You need to input the voxel you want to run trace plots on!"
        trace_plot(voxel_id,results_folder,nburnin)
        
    if plottype == "corner":
        assert voxel_id is not None, "You need to input the voxel you want to run corner plots on!"
        corner_plot(voxel_id, results_folder,nburnin)
        
    
if __name__ == "__main__":# Default to False if not specified
   
    # Read the first argument as the voxel to plot.
    if len(sys.argv) > 1:
        voxel_id = int(sys.argv[1])
    else:
        print("Indicate which voxel to run kg_plots.py on!")
        sys.exit(1)

    # Read the second argument as the type of plot.
    if len(sys.argv) > 2:
        plottype = sys.argv[2]
        assert plottype == "trace" or plottype == "corner" or plottype == "heatmap" or plottype == "residual", "Only valid plottypes are residual, heatmap, trace, and corner."
    else:
        print("Indicate what type of plot to create. Valid plottypes are residual, heatmap, trace, and corner.")
        sys.exit(1)
        
    main(voxel_id,plottype)