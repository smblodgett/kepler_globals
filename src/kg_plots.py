"""
kg_plots.py
===========

Script that creates plots for the models of the KMDC datasest.

Controlled by the script found in /runs/plotprops.txt. 
Uses the base KMDC dataset for some plots, and uses the 
posteriors generated by the models to visualise the models.

Useage
------
Run from the command line:
  python kg_plots.py voxel_id plottype

Parameters
----------
voxel_id : int
  The id number of the voxel you want to graph.
plottype : str
  The kind of plot you want to create.

Additional script control is given via /runs/plotprops.txt (see that file for control options).

Author
------
Steven Blodgett <blodgett.steven.m@gmail.com>
Created on 2025-04-02
"""

import corner
import emcee
import os
import sys
import re
import json
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap, BoundaryNorm
from matplotlib.ticker import ScalarFormatter
from PIL import Image
from scipy.stats import lognorm

from kg_param_boundary_arrays import (
    radius_grid_array as radius_param_grid_array,
    period_grid_array as period_param_grid_array,
    mass_grid_array as mass_param_grid_array,
    eccentricity_grid_array as eccentricity_param_grid_array,
    omega_grid_array as omega_param_grid_array
)

from kg_grid_boundary_arrays import radius_grid_array, period_grid_array, mass_grid_array 
from kg_griddefiner import RPMGrid, RPMeoGrid
from kg_constants import *
from kg_utilities import mass_given_density_radius, radius_given_density_mass, ReadJson
from kg_probability_distributions import get_probability_distributions, generate_catalog, synthetic_catalog_to_grid
from kg_grid_object_hook import grid_object_hook


# Set good-looking plot options
plt.rcParams['lines.linewidth']   = 2.5
plt.rcParams['axes.linewidth']    = 1.5
plt.rcParams['xtick.major.width'] =2
plt.rcParams['ytick.major.width'] =2
plt.rcParams['xtick.minor.width'] =1.5
plt.rcParams['ytick.minor.width'] =1.5
plt.rcParams['ytick.labelsize'] = 13
plt.rcParams['xtick.labelsize'] = 13
plt.rcParams['axes.labelsize'] = 18
plt.rcParams['legend.numpoints'] = 1
plt.rcParams['axes.labelweight']='semibold'
plt.rcParams['mathtext.fontset']='stix'
plt.rcParams['font.weight'] = 'semibold'
plt.rcParams['axes.titleweight']='semibold'
plt.rcParams['axes.titlesize']=12

# This will need to change based on adding new parameters...maybe this should be in the utility file?
param_labels = ['$\mathrm{log}_{10}(Γ_0)$',
                '$γ_0$',
                '$γ_1$',  
                '$γ_2$',  
                '$σ_0$',  
                '$σ_1$',   
                '$σ_2$',  
                '$M_{break,1}$',  
                '$M_{break,2}$',   
                'C',
                '$μ_M$',  
                '$σ_M$',  
                '$β_1$',
                '$β_2$',  
                '$β_3$',
                '$P_{break,1}$',   
                '$P_{break,2}$',
                '$α_e$',
                '$λ_e$',
                '$σ_e$'
                ]


def heatmap_plot(rpm_grid,results_folder,nburnin,mode="all", make_gifs=True, verbose=False, is_plot_ids=False, fps=0.5,backend_path="../results/backend",upper_rho_prior=30,is_uniform_density=False):
    """
    Plots sequences of heatmaps from the base KMDC, iterating on mass, radius, and period.
    
    The plots are stored in /results/plots/heatmaps and /results/plots/animations.
    
    Parameters
    ----------
    rpm_grid : RPMGrid
      A grid of radius-period-mass voxels (of class RPMVoxel).
    results_folder : str
      The pathway to Kepler Globals' results folder.
    mode : str, optional
      Which kind of heatmap should be plotted. Default is 'all', which plots all three types.
    make_gifs : bool, optional
      Whether the function should make a gif from its generated heatmaps (default is True).
    verbose : bool, optional
      Whether the function should produce print statements to track its progress (default is False).
    fps : float, optional
      What the frame rate for the gifs should be (default is 0.5).
    
    Returns
    -------
    None
    """
    if mode == "all" or mode == "mass":
        make_histograms(rpm_grid,results_folder,nburnin,mode="mass",make_gifs=make_gifs,verbose=verbose, is_plot_ids=is_plot_ids, fps=fps,backend_path=backend_path,upper_rho_prior=upper_rho_prior,is_uniform_density=is_uniform_density)
    if mode == "all" or mode == "period":
        make_histograms(rpm_grid,results_folder,nburnin,mode="period",make_gifs=make_gifs,verbose=verbose, is_plot_ids=is_plot_ids, fps=fps,backend_path=backend_path,upper_rho_prior=upper_rho_prior,is_uniform_density=is_uniform_density)
    if mode == "all" or mode == "radius":
        make_histograms(rpm_grid,results_folder,nburnin,mode="radius",make_gifs=make_gifs,verbose=verbose, is_plot_ids=is_plot_ids,fps=fps,backend_path=backend_path,upper_rho_prior=upper_rho_prior,is_uniform_density=is_uniform_density)


def get_arrays(mode):
    """Load the correct arrays for the heatmap plots."""
    if mode == "mass":
        x_array = period_grid_array
        y_array = radius_grid_array
        z_array = mass_grid_array
        search_dict = {"z":7,"z_next":8,"x":3,"y":5}
    elif mode == "period":
        x_array = radius_grid_array
        y_array = mass_grid_array
        z_array = period_grid_array
        search_dict = {"z":5,"z_next":6,"x":7,"y":3}
    elif mode == "radius":
        x_array = period_grid_array
        y_array = mass_grid_array
        z_array = radius_grid_array
        search_dict = {"z":3,"z_next":4,"x":7,"y":5}
    return x_array, y_array, z_array, search_dict


def make_histograms(rpm_grid, results_folder,nburnin, mode, make_gifs=True, 
                    verbose=False, is_plot_ids=False, fps=0.5,backend_path="../results/grid/backend_30",
                    upper_rho_prior=30,is_uniform_density=False): ######## tidy up this script a lot
    """This function needs to be cut down to size..."""

    assert mode == "mass" or mode == "period" or mode == "radius", "heatmaps iterate over mass, period, or radius"
    
    x_array, y_array, z_array, search_dict = get_arrays(mode)

    heatmap_folder = os.path.join(results_folder, "plots", "heatmaps",f"grid_{upper_rho_prior}",mode)
    if is_uniform_density: 
        heatmap_folder += "_uniform"
    os.makedirs(heatmap_folder, exist_ok=True)

    Rmrps = rpm_grid.get_Rmrps(nburnin,backend_path)

    all_means = Rmrps[:,0]
    vmax = np.max(all_means*100) # Express Rmrp in a percentage.
    vmin = np.min(all_means[all_means>0]*100)

    cumul_mean = np.zeros((len(y_array)-1,len(x_array)-1))
    cumul_lower = np.zeros((len(y_array)-1,len(x_array)-1))
    cumul_upper = np.zeros((len(y_array)-1,len(x_array)-1))
    is_cumul_mode = False
    for i, z in enumerate(z_array):
        
        if i == len(z_array)-1:
            is_cumul_mode = True
        if not is_cumul_mode: 
            next_z = z_array[i+1]

            mean = np.empty((len(y_array)-1,len(x_array)-1))
            lower = np.empty((len(y_array)-1,len(x_array)-1))
            upper = np.empty((len(y_array)-1,len(x_array)-1))
            ids = np.empty((len(y_array)-1,len(x_array)-1))
            annot = np.empty((len(y_array)-1, len(x_array)-1), dtype=object)

            for voxel in Rmrps:
                
                if voxel[search_dict["z"]] == z and voxel[search_dict["z_next"]] == next_z:
                    
                    x_idx = np.searchsorted(y_array, voxel[search_dict["x"]],side='right')-1
                    y_idx = np.searchsorted(x_array, voxel[search_dict["y"]],side='right')-1
                    
                    voxel[0] *= 100
                    voxel[1] *= 100
                    voxel[2] *= 100

                    mean[x_idx,y_idx] = voxel[0]
                    lower[x_idx,y_idx] = voxel[1]
                    upper[x_idx,y_idx] = voxel[2]
                    ids[x_idx,y_idx] = voxel[9]
                    if voxel[0] == 0:
                        annot[x_idx,y_idx] = f"{voxel[0]:.1f}$^{{+{voxel[2]:.1f}}}_{{-{voxel[1]:.1f}}}$%"
                    elif voxel[0] < 1e-2 and voxel[0] > 1e-3:
                        annot[x_idx,y_idx] = f"{voxel[0]:.3f}$^{{+{voxel[2]:.3f}}}_{{-{voxel[1]:.3f}}}$%"
                    elif voxel[0] < 1e-3:
                        annot[x_idx,y_idx] = f"{compact_sci(voxel[0])}$^{{+{compact_sci(voxel[2],1)}}}_{{-{compact_sci(voxel[1],1)}}}$%"
                    else:
                        annot[x_idx,y_idx] = f"{voxel[0]:.2f}$^{{+{voxel[2]:.3f}}}_{{-{voxel[1]:.3f}}}$%"

        if is_cumul_mode:
            mean = cumul_mean
            upper = cumul_upper
            lower = cumul_lower
            for row_idx, row in enumerate(mean):
                for col_idx, voxel_mean in enumerate(row):
                    if voxel_mean == 0:
                        annot[row_idx,col_idx] = f"{voxel_mean:.1f}$^{{+{upper[row_idx,col_idx]:.1f}}}_{{-{lower[row_idx,col_idx]:.1f}}}$%"
                    elif voxel[0] < 1e-2 and voxel[0] > 1e-3:
                        annot[row_idx,col_idx] = f"{voxel_mean:.3f}$^{{+{upper[row_idx,col_idx]:.3f}}}_{{-{lower[row_idx,col_idx]:.3f}}}$%"
                    elif voxel_mean < 1e-3:
                        annot[row_idx,col_idx] = f"{compact_sci(voxel_mean)}$^{{+{compact_sci(upper[row_idx,col_idx],1)}}}_{{-{compact_sci(lower[row_idx,col_idx],1)}}}$%"
                    else:
                        annot[row_idx,col_idx] = f"{voxel_mean:.2f}$^{{+{upper[row_idx,col_idx]:.3f}}}_{{-{lower[row_idx,col_idx]:.3f}}}$%"

        
        # Create a cubehelix palette

        cubehelix = sns.cubehelix_palette(start=2,rot=-1.4,n_colors=1000,light=.74,dark=0.4,reverse=False)
        # Prepend gray for zero values
        colors = [(0.6, 0.6, 0.6)] + cubehelix
        cmap = ListedColormap(colors)

        # Handle vmax if in cumulative mode
        if is_cumul_mode:
            vmax = np.max(mean[mean > 0])  # Exclude zeros for log spacing
            vmin = np.min(mean[mean>0])
        print("vmax: ",vmax)
        print("vmin: ",vmin)

        # Create boundaries:
        n_bins = len(colors) - 1  # excluding the zero bin
        log_boundaries = np.logspace(np.log10(np.nextafter(vmin, 0)), np.log10(vmax), n_bins)
        boundaries = [0] + list(log_boundaries)
        norm = BoundaryNorm(boundaries, len(colors))

        plt.figure(figsize=(10, 8),dpi=250,facecolor="#000034")
        ax = sns.heatmap(mean, annot=annot, fmt='', cmap=cmap, norm=norm,#vmin=0.0, vmax=vmax,
                        cbar=False,annot_kws={"size":6.65 if mode != "period" else 5.2,"color": "white","weight": "bold" })

        if not is_cumul_mode and is_plot_ids:
            for i in range(mean.shape[0]):      # rows (y)
                for j in range(mean.shape[1]):  # columns (x)
                    # Calculate the id number for this cell (replace with your actual logic if needed)
                    id_number = int(ids[i,j])  # Or however you want to tag it

                    # Place in upper left: x=j, y=i, with a small offset
                    ax.text(j + 0.02, i + 0.15, id_number, color='white', fontsize=3, ha='left', va='top', alpha=0.5)



        xedges = np.array(x_array)
        yedges = np.array(y_array)
        
        if not is_cumul_mode:
            heatmap_prior_line_config(ax,z,next_z,x_array,y_array,mode)


        xtick_positions = np.arange(len(xedges))
        xtick_labels = [f"{x:.2f}" if x < 1e5 else f"{x:.2e}" for x in xedges]
        ax.set_xticks(xtick_positions)
        ax.set_xticklabels(xtick_labels, rotation=45, fontsize=8,color="white")

        # Y-axis: radius bin edges
        ytick_positions = np.arange(len(yedges))
        ytick_labels = [f"{y:.2f}" if y < 1e5 else f"{y:.2e}" for y in yedges]
        ax.set_yticks(ytick_positions)
        ax.set_yticklabels(ytick_labels, rotation=0, fontsize=8,color="white")

        # Flip y-axis so smaller radii are on bottom
        ax.invert_yaxis()

        xlabel, ylabel = get_labels(mode)
        plt.grid()
        plt.xlabel(xlabel,color="white",fontsize=12)
        plt.ylabel(ylabel,color="white",fontsize=12)
        plt.suptitle(r"$\mathcal{R}_{MRP}$", fontsize=25,color="white")
        if not is_cumul_mode:
            plt.title(mode+f" {z}-{next_z}",color="white")
        else:
            plt.title(mode +" (cumulative)",color="white")
        plt.tight_layout()
        if not is_cumul_mode: 
            plt.savefig(os.path.join(heatmap_folder, mode + f"_{z}-{next_z}_heatmap.png"), dpi=300)
        else:
            plt.savefig(os.path.join(heatmap_folder, f"cumulative_"+mode+"_heatmap.png"), dpi=300)
        plt.close()
        if not is_cumul_mode: 
            cumul_mean += mean
            cumul_lower += lower
            cumul_upper += upper

    if make_gifs:
        if not is_uniform_density:
            os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps",f"grid_{upper_rho_prior}"), exist_ok=True)
            output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps",f"grid_{upper_rho_prior}", mode+"_heatmap_animation.gif")
        else:
            os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps",f"grid_{upper_rho_prior}_uniform"), exist_ok=True)
            output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps",f"grid_{upper_rho_prior}_uniform", mode+"_heatmap_animation.gif")   
        make_gif_from_pngs(heatmap_folder, output_gif_path, fps=fps)


def compact_sci(x, precision=2):
    """Makes python's default scientific notation display more compactly."""
    s = f"{x:.{precision}e}"
    base, exp = s.split("e")
    return f"{base}e{int(exp)}"


def get_labels(mode):
    """Gets the graph labels for the heatmap plot."""
    if mode == "mass":
        xlabel = "Period [days]"
        ylabel = "Radius [$R_{⊕}$]"
    elif mode == "radius":
        ylabel = "Mass [$M_{⊕}$]"
        xlabel = "Period [days]"
    elif mode == "period":
        ylabel = "Mass [$M_{⊕}$]"
        xlabel = "Radius [$R_{⊕}$]"
    else:
        raise ValueError("Invalid mode. Choose 'mass', 'radius', or 'period'.")
    return xlabel, ylabel


def heatmap_prior_line_config(ax,z,next_z,x_array,y_array,mode):
    """Helper function which prepares the prior lines for graphing, then calls the graphing function."""

    if mode == "mass":
        rho30_prior_upper = radius_given_density_mass(30,next_z)
        rho30_prior_lower = radius_given_density_mass(30,z)    
        rho10_prior_upper = radius_given_density_mass(10,next_z) 
        rho10_prior_lower = radius_given_density_mass(10,z)        
        rho001_prior_upper = radius_given_density_mass(0.01,next_z)
        rho001_prior_lower = radius_given_density_mass(0.01,z)
        rho55_earth_upper = radius_given_density_mass(5.5,next_z)
        rho55_earth_lower = radius_given_density_mass(5.5,z)

    elif mode == "radius":
        rho30_prior_upper = mass_given_density_radius(30,next_z)
        rho30_prior_lower = mass_given_density_radius(30,z)       
        rho10_prior_upper = mass_given_density_radius(10,next_z)
        rho10_prior_lower = mass_given_density_radius(10,z)        
        rho001_prior_upper = mass_given_density_radius(0.01,next_z)
        rho001_prior_lower = mass_given_density_radius(0.01,z)
        rho55_earth_upper = mass_given_density_radius(5.5,next_z)
        rho55_earth_lower = mass_given_density_radius(5.5,z)

    if (mode == "mass" or mode == "radius"):
        color_array = ["darkslategrey",'k','k',"darkslategrey"] if mode == "mass" else ['k',"darkslategrey","darkslategrey",'k']
        for colors, prior_line in zip(["aqua","aqua","dimgrey","dimgrey"]+color_array,[rho55_earth_lower,rho55_earth_upper,rho10_prior_lower,rho10_prior_upper,rho30_prior_upper,rho30_prior_lower,rho001_prior_upper,rho001_prior_lower]):
            alpha = 0.2 if colors == "aqua" else 0.7
            heatmap_prior_lines(ax,x_array,y_array,prior_line,colors=colors,alpha=alpha)
    

def heatmap_prior_lines(ax,x_bins,y_bins,prior_line_y,colors='k',alpha=0.7):
    """Helper function which plots the prior lines on the heatmaps."""
    if prior_line_y > np.max(y_bins):
        return 

    # Find the lower bin edge that encloses the prior line.
    bin_idx = np.searchsorted(y_bins, prior_line_y) - 1 

    # Make linear interpolation between bin edges.
    y_lower, y_upper = y_bins[bin_idx], y_bins[bin_idx + 1]
    frac = (prior_line_y - y_lower) / (y_upper - y_lower) 
    mapped_y = bin_idx + frac 

    # Plot the precise horizontal line.
    ax.hlines(y=mapped_y, xmin=0, xmax=len(x_bins)-1, colors=colors, linestyles='dashed',alpha=alpha)


def make_gif_from_pngs(input_dir, output_gif_path, fps=1,verbose=True,residual_iter=None):
    """Make gifs from the stacked heatmap sequences iterating through mass, period, or radius"""
    if residual_iter is None:
        png_files = [f for f in os.listdir(input_dir) if f.endswith('.png')]
    else:
        png_files = [f for f in os.listdir(input_dir) if f.endswith('.png') and f"{residual_iter}_residual" in f]
    
    file_numbers_dict = {} # Make dict with all the right png files.
    for file in png_files:

        if residual_iter is None:
            m = re.search(r'\d+\.\d+',file)
        else:
            m = re.search(rf"\d+\.\d+_{residual_iter}",file)

        if m:
            m = m.group(0)
            if residual_iter is not None:
                m = m.split("_")[0]
            value = float(m)
            file_numbers_dict[value] = file
        else:
            file_numbers_dict[9e99] = file
    
    if verbose: print(sorted(file_numbers_dict))
    images = []
    for key in sorted(file_numbers_dict): # Sort them, then create a gif out of it.
        image_path = os.path.join(input_dir, file_numbers_dict[key])
        image = Image.open(image_path)
        images.append(image)
        
    os.makedirs(os.path.dirname(output_gif_path), exist_ok=True)
    
    durations = np.ones(len(images))*1000/fps
    
    durations[-1] = 4 * 1000/fps
    
    durations = durations.astype(int).tolist()

    images[0].save(output_gif_path, save_all=True, append_images=images[1:], optimize=True, duration=durations, loop=0)

    if verbose: print(f"GIF saved to {output_gif_path}")
        
        
 ### some kind of best fit plot ??        
 ### residuals (best fit - data)

    
def trace_plot(voxel_id,results_folder,nburnin, upper_rho_limit=30,is_uniform_density=False):
    """Makes the trace plot for an individual voxel's Rmrp value."""
    voxel_grid = RPMGrid(radius_grid_array,period_grid_array,mass_grid_array)
    voxel = voxel_grid.find_voxel_by_id(voxel_id)

    trace_plot_folder = os.path.join(results_folder, "plots", "traces",f"grid_{upper_rho_limit}")
    if is_uniform_density: trace_plot_folder += "_uniform"

    os.makedirs(trace_plot_folder, exist_ok=True)
    sampler_backend_folder = results_folder + f"/grid/backend_{upper_rho_limit}"
    if is_uniform_density: sampler_backend_folder += "_uniform"
    filename = find_h5_file(voxel_id,sampler_backend_folder)
    file_path = os.path.join(sampler_backend_folder, filename)

    reader = emcee.backends.HDFBackend(file_path)

    samples = reader.get_chain()
    samples = samples[nburnin:,:,:]

    print("Chain shape:", samples.shape)
    n_steps, n_walkers, n_dim = samples.shape
    samples = np.array(samples)
    
    plt.figure(figsize=(10,5),dpi=150)
    for walker_data in samples.transpose(1,0,2):
        walker_data = np.squeeze(walker_data)
        plt.plot(np.linspace(0,n_steps,n_steps), walker_data)
    
    plt.minorticks_on()
    plt.grid()
    plt.xlabel("Step Number")
    plt.ylabel(r"$\mathcal{R}_{MRP}$")
    plt.suptitle("Trace Plot",fontsize=17)
    plt.title(f"voxel: {voxel.id_number}, R: {voxel.bottom_radius} - {voxel.top_radius}, "
            f"P: {voxel.bottom_period} - {voxel.top_period}, "
            f"M: {voxel.bottom_mass} - {voxel.top_mass})",fontsize=7)
    plt.savefig(trace_plot_folder+f"/{voxel_id}_trace.png", dpi=150)
    
    
def find_h5_file(voxel_id,sampler_backend_folder):
    """Finds the h5 file backend stored for a particular voxel."""
    voxel_id = str(voxel_id)
    h5_path = ""
    h5_files = [f for f in os.listdir(sampler_backend_folder) if f.endswith('.h5')]
    for file in h5_files:
        m = re.search("_"+voxel_id+"_",file)
        if m:
            h5_path = file
            break
    if not h5_path:
        return
    return h5_path



def param_analysis_plots(results_folder,model_run_folder,model_id,nburnin,filename,voxel_grid,kmdc_filename,model_params,stellar_df):

    df = pd.read_csv(kmdc_filename,index_col=0)    
    voxel_grid.setup_dataframes(df.columns)
    voxel_grid.add_data(df)

    visualization_plot_folder = os.path.join(results_folder,"param_runs",f"model_{model_id}",model_run_folder)
    os.makedirs(visualization_plot_folder, exist_ok=True)
    
    file_path = os.path.join(visualization_plot_folder, filename)

    reader = emcee.backends.HDFBackend(file_path)

    log_prob = reader.get_log_prob(discard=nburnin, flat=True)
    samples = reader.get_chain(discard=nburnin, flat=True)

    top_idx = np.argsort(log_prob)[-1000:] 

    top_samples = samples[top_idx]
    top_log_prob = log_prob[top_idx]

    print("max top log prob: ",max(top_log_prob))
    print("max log prob: ",max(log_prob))

        # Sort by likelihood descending
    order = np.argsort(top_log_prob)[::-1]
    top_samples = top_samples[order]
    top_log_prob = top_log_prob[order]

    print(top_samples)
    print(top_log_prob)
    print("max top log prob: ",max(top_log_prob),"top log prob[0]: ",top_log_prob[0])

    with open(visualization_plot_folder+"/rng_metadata.json") as f:
        rng_metadata = json.load(f)
    
    master_seed = rng_metadata["master_seed"]
    rank = rng_metadata["rank"]
    time_seed = rng_metadata["time_seed"]

    γ0 = top_samples[:,1]
    γ1 = top_samples[:,2]
    γ2 = top_samples[:,3]
    σ0 = top_samples[:,4]
    σ1 = top_samples[:,5]
    σ2 = top_samples[:,6]
    mass_break_1 = top_samples[:,7]
    mass_break_2 = top_samples[:,8]
    C = top_samples[:,9]
    μM = top_samples[:,10]
    σM = top_samples[:,11]
    β1 = top_samples[:,12]
    β2 = top_samples[:,13]
    β3 = top_samples[:,14]
    Period_break_1 = top_samples[:,15]
    Period_break_2 = top_samples[:,16]
    α = top_samples[:,17]
    λ = top_samples[:,18]
    σ_e = top_samples[:,19]


    print("model_params: ", model_params)
    print("log10(Gamma0) model_params[0]: ", model_params[0])
    print("top samples: ",top_samples)

    Gamma0 = 10**model_params[0]

    
    p_Period, Period_fine_grid, p_mass, mass_fine_grid,γ0,γ1,γ2,mass_break_1,mass_break_2,σ0,σ1,σ2,C, p_ecc, eccentricity_fine_grid, is_nan_in_pmfs, is_inf_in_pmfs = get_probability_distributions(model_params)
    synthetic_catalog, rng_metadata = generate_catalog(stellar_df,p_Period, Period_fine_grid, p_mass, mass_fine_grid, γ0,γ1,γ2,mass_break_1,mass_break_2,σ0,σ1,σ2,C, p_ecc, eccentricity_fine_grid,rank,master_seed,time_seed)
    voxel_grid = synthetic_catalog_to_grid(synthetic_catalog,voxel_grid)

    voxel_num_data = voxel_grid.likelihood_array[:,:,:,:,:,0]
    model_count = Gamma0 * voxel_grid.likelihood_array[:,:,:,:,:,1]

    def rayleigh_exponential(alpha,lamb,sigma,e):
        return (alpha*((lamb*np.exp(-lamb*e))/(1-np.exp(-lamb))) + 
                (1-alpha)*((2*e*(1/(2*sigma**2))*np.exp(-1*e**2/(2*sigma**2)))/(1-np.exp(-1/(2*sigma**2)))))
    
    ecc = np.linspace(0,1,900)
    plt.figure(dpi=300,facecolor="w")
    for n in range(len(top_samples)):
        plt.plot(ecc,rayleigh_exponential(α[n],λ[n],σ_e[n],ecc),alpha=0.01,linewidth=1, c='b')
    plt.plot(ecc,rayleigh_exponential(α[0],λ[0],σ_e[0],ecc),alpha=0.5, c='r',label="best fit")
    
    data_ecc = np.array([])
    for voxel in voxel_grid.voxel_array.flat:
        data_ecc = np.append(data_ecc,voxel.df["e"])
    
    plt.hist(data_ecc,bins=1000,density=True)

    model_count_ecc = np.sum(model_count, axis=(0,1,2,4))

    print("model_count.shape: ",model_count.shape)
    print("model_count_ecc.shape: ", model_count_ecc.shape)
    print("len(model_count_ecc): ",len(model_count_ecc))
    print("len(eccentricity_param_grid_array) - 1: " ,len(eccentricity_param_grid_array) - 1 )

    assert len(model_count_ecc) == len(eccentricity_param_grid_array) - 1 

    plt.hist(model_count_ecc,bins=eccentricity_param_grid_array)

    plt.xlabel("eccentricity",fontsize=10)
    plt.legend()
    plt.title('Close-in Exoplanet Eccentricity Distribution')
    plt.savefig(visualization_plot_folder+'/model_ecc.png')


    data_mass = np.array([])
    for voxel in voxel_grid.voxel_array.flat:
        data_mass = np.append(data_mass,voxel.df["M_pE"])

    masses = np.logspace(-1,2.2,10000)
    plt.figure(dpi=300,facecolor="w")
    for n in range(len(top_samples)):
        plt.semilogy(masses,lognorm.pdf(masses,s=np.exp(μM[n]),scale=np.exp(σM[n])),alpha=0.01,linewidth=1.1, c="b")
    plt.semilogy(masses,lognorm.pdf(masses,s=np.exp(μM[0]),scale=np.exp(σM[0])),alpha=0.5, c='r',label="best fit")
    plt.semilogy(masses,lognorm.pdf(masses,s=np.exp(1.00),scale=np.exp(1.65)),alpha=0.5, c='g',label="N&R 2020") ### wtfreak logs? 


   
    # Compute histogram counts manually
    counts, bins = np.histogram(data_mass, bins=10000, density=True)

    model_count_mass = np.sum(model_count, axis=(0,1,3,4))
    assert len(model_count_mass) == len(mass_param_grid_array) - 1 


    counts_model, bins_model = np.histogram(model_count_mass,bins=mass_param_grid_array,density=True)


    # Plot as a bar plot on the same axes
    bin_centers = 0.5 * (bins[:-1] + bins[1:])
    bin_centers_model = 0.5 * (bins_model[:-1] + bins_model[1:])
    plt.bar(bin_centers, counts, width=(bins[1]-bins[0]), alpha=0.5, label="log histogram (observed data)")
    plt.bar(bin_centers_model, counts_model, width=(bins_model[1]-bins_model[0]), alpha=0.5, label="log histogram (model)")


    plt.ylim([1e-3,1.2])
    plt.xlim([0,200])
    plt.xlabel("Mass [$M_{⊕}$]",fontsize=10)
    plt.legend()
    plt.title('Close-in Exoplanet Mass Distribution')
    plt.savefig(visualization_plot_folder+'/model_mass.png')

    print("best fit mu_M:",μM[0] )
    print("best fit sigma_M:",σM[0] )

    param_trace_plot(results_folder,model_run_folder,model_id,nburnin,filename)

    param_corner_plot(results_folder,model_run_folder,model_id,nburnin,filename)




def param_corner_plot(results_folder,model_run_folder,model_id,nburnin,filename):
    corner_plot_folder = os.path.join(results_folder,"param_runs",f"model_{model_id}",model_run_folder)
    os.makedirs(corner_plot_folder, exist_ok=True)

    file_path = os.path.join(corner_plot_folder, filename)

    reader = emcee.backends.HDFBackend(file_path)

    samples = reader.get_chain()
    samples = samples[nburnin:,:,:]

    print("Chain shape:", samples.shape)

    n_steps, n_walkers, n_dim = samples.shape
    samples = np.array(samples)

    

    samples_2d = samples.reshape(-1, samples.shape[-1])
    
    corner_plot = corner.corner(samples_2d,labels=param_labels,show_titles=True)
    # plt.suptitle("         Corner Plot") ????
    plt.suptitle(f"Model {model_id}",fontsize=200)
    
    corner_plot.savefig(corner_plot_folder+f"/model_corner.png",dpi=150)


def param_trace_plot(results_folder,model_run_folder,model_id,nburnin,filename):
    
    
    trace_plot_folder = os.path.join(results_folder,"param_runs",f"model_{model_id}",model_run_folder)
    os.makedirs(trace_plot_folder, exist_ok=True)

    print("trace_plot_folder: ", trace_plot_folder)


    file_path = os.path.join(trace_plot_folder, filename)

    reader = emcee.backends.HDFBackend(file_path)

    print("reader.iteration: ",  reader.iteration)

    print("reader.accepted: ",  reader.accepted)

    print("reader.accepted / reader.rejected: ", np.mean(reader.accepted / reader.iteration))


    samples = reader.get_chain()
    samples = samples[nburnin:,:,:]
    
    n_steps, n_walkers, n_params = samples.shape

    

      # Determine grid layout
    n_cols = 4
    n_rows = int(np.ceil(n_params / n_cols))

    fig, axes = plt.subplots(n_rows, n_cols, figsize=(8*n_cols, 2.5*n_rows), sharex=True)
    axes = axes.flatten()  # flatten in case of a grid

    for i in range(n_params):
        ax = axes[i]
        for walker in range(n_walkers):
            ax.plot(samples[:, walker, i], alpha=0.1, lw=0.8)
        ax.set_ylabel(param_labels[i], fontsize=8)
        ax.tick_params(axis='both', which='major', labelsize=7)

    # Remove any unused subplots
    for j in range(n_params, len(axes)):
        fig.delaxes(axes[j])

    axes[-1].set_xlabel("Step")
    # plt.tight_layout()
    fig.savefig(os.path.join(trace_plot_folder, f"model_trace.png"), dpi=150)
    plt.close(fig)

    # n_steps, n_walkers, n_params = samples.shape
    # print("n_params:", n_params)
    # print("samples: ", samples)

    # for i in range(n_params):
    #     fig, ax = plt.subplots(figsize=(10, 2.5))
    #     for walker in range(n_walkers):
    #         ax.plot(samples[:, walker, i], alpha=0.1, lw=0.8)
    #     label = param_labels[i]
    #     # ax.set_title(f"Trace plot for {label}")
    #     ax.set_xlabel("Step")
    #     ax.set_ylabel(label)
    #     plt.tight_layout()

    # plt.savefig(trace_plot_folder+f"/{model_id}_trace.png",dpi=150)



def grid_corner_plot(voxel_id, results_folder, nburnin,upper_rho_limit=30,is_uniform_density=False):
    """Makes the corner plot for an individual voxel's Rmrp value."""
    voxel_grid = RPMGrid(radius_grid_array,period_grid_array,mass_grid_array)
    voxel = voxel_grid.find_voxel_by_id(voxel_id)

    corner_plot_folder = os.path.join(results_folder, "plots", "corners",f"grid_{upper_rho_limit}")
    if is_uniform_density: corner_plot_folder += "_uniform"
    os.makedirs(corner_plot_folder, exist_ok=True)
    sampler_backend_folder = results_folder + f"/grid/backend_{upper_rho_limit}"
    if is_uniform_density: sampler_backend_folder += "_uniform"
    filename = find_h5_file(voxel_id,sampler_backend_folder)
    file_path = os.path.join(sampler_backend_folder, filename)

    reader = emcee.backends.HDFBackend(file_path)

    samples = reader.get_chain()
    samples = samples[nburnin:,:,:]

    print("Chain shape:", samples.shape)

    n_steps, n_walkers, n_dim = samples.shape
    samples = np.array(samples)
    
    corner_plot = corner.corner(samples.reshape(-1,1),labels=[r"$\mathcal{R}_{MRP}$"])
    # plt.suptitle("         Corner Plot") ????
    plt.title(f"voxel: {voxel.id_number}, R: {voxel.bottom_radius} - {voxel.top_radius}, "
                f"P: {voxel.bottom_period} - {voxel.top_period}, "
                f"M: {voxel.bottom_mass} - {voxel.top_mass})",fontsize=7)
    
    corner_plot.savefig(corner_plot_folder+f"/{voxel_id}_corner.png",dpi=150)


def MES_grid_plot(completeness_interp,save_path="../results/plots/completeness/",mass_fixed=1.0,ecc_fixed=0.0,omega_fixed=0.0):
    os.makedirs(os.path.dirname(save_path + '/completeness/'), exist_ok=True)
    radius_grid_array,period_grid_array,mass_grid_array,eccentricity_grid_array,omega_grid_array = completeness_interp.grid

    X1, X2 = np.meshgrid(radius_grid_array, period_grid_array, indexing='ij')

    pts = np.column_stack([X1.ravel(), X2.ravel(), np.full(X1.size, mass_fixed),
                           np.full(X1.size, ecc_fixed), np.full(X1.size, omega_fixed)])
    
    # Z1 = detection_interp(pts).reshape(X1.shape)
    # Z2 = transit_interp(pts).reshape(X1.shape)
    Z3 = completeness_interp(pts).reshape(X1.shape)

    filled_levels = np.linspace(0, 1, 100)
    contour_levels = [0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.75,1.0]

    # plt.figure()
    # cf = plt.contourf(X2,X1, Z1*Z2, levels=filled_levels, cmap='Grays')
    # cs = plt.contour(X2,X1, Z1*Z2, levels=contour_levels, colors='g', linewidths=0.5)
    # plt.clabel(cs, inline=True, fontsize=8, fmt='%.2f', colors='g',inline_spacing=3)
    # cbar = plt.colorbar(cf)
    # cbar.set_label('Completeness') 
    # cbar.set_ticks(contour_levels)

    # plt.ylabel('Radius [R⊕]')
    # plt.xlabel('Period [days]')
    # plt.xlim([0,20])
    # # plt.semilogx()
    # # plt.semilogy()
    # plt.title('MES Detection Probability')
    # plt.savefig(save_path + 'MES_detection_probability.png', dpi=300)

    fig, ax = plt.subplots()

    cf = ax.contourf(X2, X1, Z3, levels=filled_levels, cmap='Greys_r')
    cs = ax.contour(X2, X1, Z3, levels=contour_levels, colors='green', linewidths=0.5)
    ax.clabel(cs, inline=True, fontsize=8, fmt='%.2f', colors='green', inline_spacing=3)

    # Set log scales
    ax.set_xscale('log')
    ax.set_yscale('log')

    # Set custom ticks
    ax.set_xticks([0.3, 0.5, 1, 2, 5, 10, 20, 50, 100])
    ax.set_yticks([0.3, 0.5, 1, 2, 5, 10, 20])

    # Format ticks to use normal decimal (not scientific notation)
    ax.get_xaxis().set_major_formatter(ScalarFormatter())
    ax.get_yaxis().set_major_formatter(ScalarFormatter())

    ax.tick_params(axis='x', labelsize=9)
    
    # Ensure minor ticks are shown
    ax.minorticks_off()

    # Axis labels and title
    ax.set_xlabel('Period [days]')
    ax.set_ylabel('Radius [R⊕]')
    ax.set_title(f'Kepler Detection Probability,e={ecc_fixed},$\omega={omega_fixed}$,M={mass_fixed}')

    # Colorbar with matching contour levels
    cbar = plt.colorbar(cf, ax=ax)
    cbar.set_label('Completeness')
    cbar.set_ticks(contour_levels)

    plt.tight_layout()
    plt.savefig(save_path + f'/completeness/MES_detection_probability_{ecc_fixed}_{omega_fixed}_{mass_fixed}.png', dpi=300)


def residual_plot(rpm_grid,results_folder,nburnin,mode="all",verbose=False,fps=0.5,backend_path="../results/grid/backend_30",make_gifs=True):
    """
    Makes the residual plot for an individual voxel's Rmrp value.
    
    Parameters
    ----------
    rpm_grid : RPMGrid
      A grid of radius-period-mass voxels (of class RPMVoxel).
    results_folder : str
      The pathway to Kepler Globals' results folder.
    nburnin : int
      The number of burn-in steps to skip in the MCMC chain.
    mode : str, optional
      The type of residual plot to create. Default is 'all', which plots all three types.
    verbose : bool, optional
      Whether the function should produce print statements to track its progress (default is False).
    fps : float, optional
      What the frame rate for the gifs should be (default is 0.5).
    
    Returns
    -------
    None
    """

    if mode == "all" or mode == "mass":
        make_residuals(rpm_grid,results_folder,nburnin,mode="mass",verbose=verbose,fps=fps,backend_path=backend_path,make_gifs=make_gifs)
        make_residuals(rpm_grid,results_folder,nburnin,mode="mass",verbose=verbose,fps=fps,backend_path=backend_path,switch=True,make_gifs=make_gifs)

    if mode == "all" or mode == "period":
        make_residuals(rpm_grid,results_folder,nburnin,mode="period",verbose=verbose,fps=fps,backend_path=backend_path,make_gifs=make_gifs)
        make_residuals(rpm_grid,results_folder,nburnin,mode="period",verbose=verbose,fps=fps,backend_path=backend_path,switch=True,make_gifs=make_gifs)
    if mode == "all" or mode == "radius":
        make_residuals(rpm_grid,results_folder,nburnin,mode="radius",verbose=verbose,fps=fps,backend_path=backend_path,make_gifs=make_gifs)
        make_residuals(rpm_grid,results_folder,nburnin,mode="radius",verbose=verbose,fps=fps,backend_path=backend_path,switch=True,make_gifs=make_gifs)

def make_residuals(rpm_grid,results_folder,nburnin,mode="mass",verbose=False,fps=0.5,backend_path="../results/backend",switch=False,make_gifs=True):
    """
    Makes the residuals for a given voxel.
    
    Parameters
    ----------
    rpm_grid : RPMGrid
      A grid of radius-period-mass voxels (of class RPMVoxel).
    results_folder : str
      The pathway to Kepler Globals' results folder.
    nburnin : int
      The number of burn-in steps to skip in the MCMC chain.bin_edges
    mode : str, optional
      The type of residual plot to create. Default is 'mass'.
    verbose : bool, optional
      Whether the function should produce print statements to track its progress (default is False).
    fps : float, optional
      What the frame rate for the gifs should be (default is 0.5).
    
    Returns
    -------
    None
    """
    
    assert mode == "mass" or mode == "period" or mode == "radius", "residuals iterate over mass, period, or radius"
    
    if not switch:
        x_array, y_array, z_array, search_dict = get_arrays(mode)
    else:
        y_array, x_array, z_array, search_dict = get_arrays(mode)

    residual_folder = os.path.join(results_folder, "plots", "residuals","normal",mode)
    os.makedirs(residual_folder, exist_ok=True)

    Rmrps = rpm_grid.get_Rmrps(nburnin,backend_path)

    cumul_mean = np.zeros((len(y_array)-1))
    cumul_lower = np.zeros((len(y_array)-1))
    cumul_upper = np.zeros((len(y_array)-1))
    is_cumul_mode = False
    print("x_array: ", x_array)
    print("y_array: ", y_array)

    over_dimension = None

    for i, z in enumerate(z_array):
        
        if i == len(z_array)-1:
            is_cumul_mode = True
            
        if not is_cumul_mode: 
            next_z = z_array[i+1]

            mean = np.zeros((len(y_array)-1))
            lower = np.zeros((len(y_array)-1))
            upper = np.zeros((len(y_array)-1))

            for voxel in Rmrps:
            #   print("nextz_comp: ",voxel[search_dict["z_next"]], next_z)

                if voxel[search_dict["z"]] == z and voxel[search_dict["z_next"]] == next_z:
                    dict_key = "x" if not switch else "y"
                    idx = np.searchsorted(y_array, voxel[search_dict[dict_key]],side='right')-1
                    # print("y_idx: ",y_idx)5
                    # print("voxel[0]: ",voxel[0])
                    mean[idx] += voxel[0] * 100
                    lower[idx] += voxel[1] * 100
                    upper[idx] += voxel[2] * 100
                    # input("mean: "+str(mean)+" lower: "+str(lower)+" upper: "+str(upper))
                    
        if is_cumul_mode:
            mean = cumul_mean
            upper = cumul_upper
            lower = cumul_lower
            

        bins = range(len(mean))  # len(mean) = N bins
        bin_edges = y_array      # N+1 edges for N bins

        plt.figure()
        plt.bar(bins, mean, width=1, align='edge', alpha=0.7, color='skyblue',zorder=2)

        yerr = [lower, upper]

        # Add error bars at center of each bin
        bin_centers = np.array(bins) + 0.5  # center of each bar if width=1
        plt.errorbar(
            bin_centers,
            mean,
            yerr=yerr,
            fmt='none',
            color='black',
            ecolor='gray',
            elinewidth=0.75,
            capsize=3,
            label=r'$1\sigma$ Error Bars'
        )

        plt.grid(axis='y', linestyle='--', alpha=0.7)

        if not switch:
            xlabel, ylabel = get_labels(mode) 
        else:
            ylabel, xlabel = get_labels(mode)

        if not is_cumul_mode: 
            plt.title(f'Residuals for {mode} {z}-{next_z}')
        else: 
            plt.title(f'Residuals for {mode} (cumulative)')
        # Use all N+1 bin edges as tick labels
        plt.xticks(
            ticks=np.arange(len(bin_edges)),  # 0 to N
            labels=[f"{v:.2f}" if v < 1e4 else f"{v:.2e}" for v in bin_edges],
            rotation=45
        )

        plt.xlabel(ylabel)
        plt.ylabel(r'$\mathcal{R}_{MRP}$')
        plt.tight_layout()
        plt.show()

        over_dimension = ylabel.split()[0].lower()

        if not is_cumul_mode: 
            plt.savefig(os.path.join(residual_folder, mode + f"_{z}-{next_z}_{over_dimension}_residual.png"), dpi=200)
        else:
            plt.savefig(os.path.join(residual_folder, f"cumulative_"+mode+f"_{over_dimension}_residual.png"), dpi=200)
        plt.close()  # Close the plot to free memory
        # input()
        if not is_cumul_mode: 
            cumul_mean += mean
            cumul_lower += lower
            cumul_upper += upper

    if make_gifs:
        os.makedirs(os.path.join(results_folder, "plots", "animations","residuals","normal"), exist_ok=True)
        output_gif_path = os.path.join(results_folder, "plots", "animations","residuals","normal", mode+f"_over_{over_dimension}_residual_animation.gif")
        make_gif_from_pngs(residual_folder, output_gif_path, fps=fps, residual_iter=over_dimension)

    

    
def main(voxel_id,plottype,model_run_folder_argv):
    
    cwd = os.getcwd()

    # Find the plotprops path.
    if 'src' in cwd:
        plotprops_filename = "../runs/plotprops.txt"
    elif 'runs' in cwd:
        plotprops_filename = "plotprops.txt"
    elif 'results' in cwd:
        plotprops_filename = "plotprops.txt"
    else:
        print('you are not starting from a proper directory. you should run kg_plots.py from a src, runs, or a results directory.')
        sys.exit()
        
    # Get plotprops loaded in.
    getData = ReadJson(plotprops_filename)
    plotprops = getData.outProps()
    nburnin = plotprops.get("nburnin")
    verbose = plotprops.get("verbose")
    # plottype = plotprops.get("plottype")
    input_data_filename = plotprops.get("input_data_filename")
    results_folder = plotprops.get("results_folder")
    upper_rho_prior = plotprops.get("upper_rho_prior")
    is_uniform_density = plotprops.get("uniform_densities")
    backend_path = plotprops.get("backend_path") + f"{upper_rho_prior}"
    if is_uniform_density:
        backend_path += "_uniform"
    make_gifs = plotprops.get("make_gifs")
    fps = plotprops.get("fps")
    is_plot_ids = plotprops.get("is_plot_ids")
    heatmap_plot_type = plotprops.get("heatmap_plot_type")
    residual_plot_type = plotprops.get("residual_plot_type")
    model_id = plotprops.get("model_id")
    param_result_filename = plotprops.get("param_result_filename")
    model_run_folder = plotprops.get("model_run_folder") 
    voxel_grid_json_object_filename = plotprops.get("voxel_json_filename")

    best_guess_filename = plotprops["best_guess_filename"] + f'_{model_id}.json'

    
    if model_run_folder_argv is not None:
        model_run_folder = model_run_folder_argv
    
    print("Plotting: ", plottype)
    
    voxel_grid = RPMGrid(radius_grid_array,period_grid_array,mass_grid_array)
    with open(voxel_grid_json_object_filename, "r") as f:
        voxel_grid_param = json.load(f,object_hook=grid_object_hook)
    with open('../data/dataframe_column_names.json', "r") as f:
        df_columns = json.load(f)
    voxel_grid_param.assign_column_names(df_columns)
    stellar_df = pd.read_csv(plotprops["processed_stellar_data_filename"])
    
    with open(best_guess_filename, "r") as f:
        saved = json.load(f)
        logp = saved["log_prob"]
        params = saved["params"]


# Default to False if not specified
    # Actually make the plots.
    if plottype == "residual":
        residual_plot(voxel_grid,results_folder,nburnin,mode=residual_plot_type,verbose=verbose,fps=fps,backend_path=backend_path,make_gifs=make_gifs)
    
    if plottype == "heatmap":
        heatmap_plot(voxel_grid,results_folder,nburnin,mode=heatmap_plot_type,make_gifs=make_gifs,verbose=verbose,
                     is_plot_ids=is_plot_ids,fps=fps,backend_path=backend_path,upper_rho_prior=upper_rho_prior, is_uniform_density=is_uniform_density)
             
    if plottype == "trace":
        assert voxel_id is not None, "You need to input the voxel you want to run trace plots on!"
        trace_plot(voxel_id,results_folder,nburnin,upper_rho_limit=upper_rho_prior,is_uniform_density=is_uniform_density)
        
    if plottype == "grid_corner":
        assert voxel_id is not None, "You need to input the voxel you want to run corner plots on!"
        grid_corner_plot(voxel_id, results_folder,nburnin,upper_rho_limit=upper_rho_prior,is_uniform_density=is_uniform_density)
        
    if plottype == "param_corner":
        param_corner_plot(results_folder,model_run_folder,model_id,nburnin,param_result_filename)
    
    if plottype == "param_trace":
        param_trace_plot(results_folder,model_run_folder,model_id,nburnin,param_result_filename)

    if plottype == "param_analysis":
        param_analysis_plots(results_folder,model_run_folder,model_id,nburnin,param_result_filename,voxel_grid_param,input_data_filename,params,stellar_df)

    
if __name__ == "__main__":# Default to False if not specified
   
    # Read the second argument as the type of plot.
    if len(sys.argv) > 1:
        plottype = sys.argv[1]
        print("plottype: ", plottype)

        voxel_id = 0
        assert plottype == "trace" or plottype == "param_analysis" or plottype == "param_corner" or plottype == "param_trace" or plottype == "grid_corner" or plottype == "heatmap" or plottype == "residual", "Only valid plottypes are residual, heatmap, trace, and grid_ or param_corner."
    else:
        print("Indicate what type of plot to create. Valid plottypes are residual, heatmap, trace, and grid_ or param_ corner.")
        sys.exit(1)

    model_run_folder = None

    # Read the first argument as the voxel to plot.
    if len(sys.argv) > 2:
        voxel_id = int(sys.argv[2])

    if os.path.isfile("model_run_folder.json"):
        model_run_folder = ReadJson("model_run_folder.json").outProps()["model_run_folder"]
        
    main(voxel_id,plottype,model_run_folder)