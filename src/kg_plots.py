"""
kg_plots.py
===========

Script that creates plots for the models of the KMDC datasest.

Controlled by the script found in /runs/plotprops.txt. Uses the 
base KMDC dataset for some plots, and will eventually use
the posteriors generated by the models to visualise the models.

Useage
------
Run from the command line:
  python kg_plots.py
  
Control via /runs/plotprops.txt (see that file for control options).

Author
------
Steven Blodgett <blodgett.steven.m@gmail.com>
Created on 2025-04-02
"""

import corner
import emcee
import h5py
import os
import sys
import commentjson as json
import re
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from PIL import Image

from kg_grid_boundary_arrays import radius_grid_array, period_grid_array, mass_grid_array
from kg_griddefiner import *


class ReadJson:
    """Read and store the contents of a Json file in a dict."""
    def __init__(self, filename):
        """Load the Json file."""
        print('reading in the plotprops.txt file')
        self.data = json.load(open(filename))
    def outProps(self):
        """Return the parsed Json dictionary."""
        return self.data

    
def heatmap_plot(rpm_grid,results_folder, make_gifs=True, verbose=False, fps=0.5, is_flat_density=False,make_cumulative=True):
    """
    Plots sequences of heatmaps from the base KMDC, iterating on mass, radius, and period.
    
    The plots are stored in /results/plots/heatmaps and /results/plots/animations.
    
    Parameters
    ----------
    rpm_grid : RPMGrid
      A grid of radius-period-mass voxels (of class RPMVoxel).
    results_folder : str
      The pathway to Kepler Globals' results folder.
    make_gifs : bool, optional
      Whether the function should make a gif from its generated heatmaps (default is True).
    verbose : bool, optional
      Whether the function should produce print statements to track its progress (default is False).
    fps : float, optional
      What the frame rate for the gifs should be (default is 0.5).
    
    Returns
    -------
    None
    """
    if is_flat_density:
        heatmap_df = get_uniform_density_prior_df(rpm_grid)
    else:
        heatmap_df = get_heatmap_df(rpm_grid)
    make_mass_histograms(rpm_grid,results_folder,heatmap_df,make_gifs=make_gifs,verbose=verbose,fps=fps,is_flat_density=is_flat_density,make_cumulative=make_cumulative)
    make_radius_histograms(rpm_grid,results_folder,heatmap_df,make_gifs=make_gifs,verbose=verbose,fps=fps,is_flat_density=is_flat_density,make_cumulative=make_cumulative)
    make_period_histograms(rpm_grid,results_folder,heatmap_df,make_gifs=make_gifs,verbose=verbose,fps=fps,is_flat_density=is_flat_density,make_cumulative=make_cumulative)

    
def get_heatmap_df(rpm_grid):
    """Create a dataframe for the heatmap of only the relevant values."""
    heatmap_df = pd.DataFrame()

    for voxel in rpm_grid.voxel_array.flat:
        df_selected = voxel.df[['R_pE', 'Period_days', 'M_pE', 'mass_divided_weights']]
        heatmap_df = pd.concat([heatmap_df, df_selected], ignore_index=True)

    return heatmap_df

def get_uniform_density_prior_df(rpm_grid):
    """Create a dataframe for the heatmap of the flat density prior."""
    heatmap_df = pd.DataFrame()
    
    for i in rpm_grid.voxel_array:
        for j in i:
            for k in j:
                df_selected = k.df[['R_pE', 'Period_days', 'M_pE', 'mass_divided_weights']]
                heatmap_df = pd.concat([heatmap_df, df_selected], ignore_index=True)
    
    
    M_30_priors = ((4/3)*np.pi*30/MEG)*(heatmap_df["R_pE"] * RECM)**3

    M_001_priors = ((4/3)*np.pi*0.01/MEG)*(heatmap_df["R_pE"] * RECM)**3 ### check upper limit and lower limit of contours
    
    heatmap_df["M_pE"] = np.random.uniform(M_001_priors,M_30_priors,len(heatmap_df["M_pE"]))
    return heatmap_df
    

def make_mass_histograms(rpm_grid,results_folder,histogram_df,make_gifs=True, verbose=False, fps=0.5, is_flat_density=False,make_cumulative=True):
    """Make heatmaps iterating through mass."""
    if not is_flat_density: heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","normal","mass")
    if is_flat_density:  heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","flat_density","mass")
    os.makedirs(heatmap_folder, exist_ok=True)
    
    cumulative_hist_slices = []
    xedges = None
    yedges = None
    vmax = 0
    for i in range(len(rpm_grid.mass_grid_array) - 1): # Figure out what the max value of the histogram is going to be.
        lower_mass = rpm_grid.mass_grid_array[i]
        upper_mass = rpm_grid.mass_grid_array[i + 1]


        mass_filtered_df = histogram_df[(histogram_df["M_pE"] > lower_mass) & (histogram_df["M_pE"] <= upper_mass)]
        period_data = mass_filtered_df["Period_days"].values
        radius_data = mass_filtered_df["R_pE"].values
        weights = mass_filtered_df["mass_divided_weights"].values # I think I need to split this the other way too...

        hist, xedges, yedges = np.histogram2d(radius_data, period_data, 
                                              bins=[rpm_grid.radius_grid_array, rpm_grid.period_grid_array], 
                                              weights=weights)  
        
        hist /= 1000
        
        cumulative_hist_slices.append(hist)
        
        vmax = max(vmax, np.nanmax(hist))

    for i in range(len(rpm_grid.mass_grid_array) - 1):
        lower_mass = rpm_grid.mass_grid_array[i]
        upper_mass = rpm_grid.mass_grid_array[i + 1]

        mass_filtered_df = histogram_df[(histogram_df["M_pE"] > lower_mass) & (histogram_df["M_pE"] <= upper_mass)]
        period_data = mass_filtered_df["Period_days"].values
        radius_data = mass_filtered_df["R_pE"].values
        weights = mass_filtered_df["mass_divided_weights"].values 

        R_30_prior_upper = (((upper_mass)*MEG)/((4/3)*np.pi*30))**(1/3) / RECM
        R_30_prior_lower = (((lower_mass)*MEG)/((4/3)*np.pi*30))**(1/3) / RECM          


        R_001_prior_upper = (((upper_mass)*MEG)/((4/3)*np.pi*0.01))**(1/3) / RECM
        R_001_prior_lower = (((lower_mass)*MEG)/((4/3)*np.pi*0.01))**(1/3) / RECM

        hist, xedges, yedges = np.histogram2d(radius_data, period_data, 
                                              bins=[rpm_grid.radius_grid_array, rpm_grid.period_grid_array], 
                                              weights=weights)

        hist /= 1000
        
        plt.figure(figsize=(8, 6), dpi=200)

        ax = sns.heatmap(hist, annot=True, fmt=".4f", cbar=False, 
                         cmap=plt.cm.Spectral, vmin=0, vmax=vmax, annot_kws={"size": 5})
        #### put a line to denote where it's hard to detect planets?

        for prior_line in [R_30_prior_upper,R_30_prior_lower,R_001_prior_upper,R_001_prior_lower]:
            heatmap_prior_lines(ax,rpm_grid.period_grid_array,rpm_grid.radius_grid_array,prior_line)

        ax.set_xticks(np.arange(len(yedges)))
        ax.set_xticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in yedges], 
                            fontsize=5)

        ax.set_yticks(np.arange(len(xedges)))
        ax.set_yticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in xedges],rotation=90, fontsize=5)

        ax.invert_yaxis()

        plt.xlabel('Period [days]')
        plt.ylabel('Radius [$R_{Earth}$]')

        plt.suptitle("Occurrence-Weighted Fraction of PhoDyMM Kepler Systems", fontsize=15)
        if is_flat_density: plt.title(f"Flat Density, M={lower_mass}-{upper_mass}")
        if not is_flat_density: plt.title(f"M={lower_mass}-{upper_mass}")

        if not is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"M{lower_mass}-{upper_mass}_heatmap.png"), dpi=200)
        if is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"M{lower_mass}-{upper_mass}_flat_density_heatmap.png"), dpi=200)
        if verbose: 
            print(f"made M{lower_mass}-{upper_mass}_heatmap.png")
        plt.close()
        
    if make_cumulative:
        base_hist = cumulative_hist_slices[0] - cumulative_hist_slices[0]
        for hist in cumulative_hist_slices:
            base_hist += hist
        
        vmax = np.max(base_hist)
        plt.figure(figsize=(8, 6), dpi=200)

        ax = sns.heatmap(base_hist, annot=True, fmt=".4f", cbar=False, 
                         cmap=plt.cm.Spectral, vmin=0, vmax=vmax, annot_kws={"size": 5})
        
        ax.set_xticks(np.arange(len(yedges)))
        ax.set_xticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in yedges], 
                            fontsize=5)

        ax.set_yticks(np.arange(len(xedges)))
        ax.set_yticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in xedges],rotation=90, fontsize=5)

        ax.invert_yaxis()

        plt.xlabel('Period [days]')
        plt.ylabel('Radius [$R_{Earth}$]')

        plt.suptitle("Occurrence-Weighted Fraction of PhoDyMM Kepler Systems", fontsize=15)
        if is_flat_density: plt.title(f"Flat Density, Cumulative Mass")
        if not is_flat_density: plt.title(f"Cumulative Mass")

        if not is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"cumulative_mass_heatmap.png"), dpi=200)
        if is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"cumulative_mass_flat_density_heatmap.png"), dpi=200)
            
        if verbose:
            print(f"made cumulative_mass_heatmap.png")
        plt.close()
            
    if make_gifs:
        if not is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","normal"), exist_ok=True)
        if is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","flat_density"), exist_ok=True)
        if not is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps","normal", "mass_heatmap_animation.gif")
        if is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps","flat_density", "mass_flat_density_heatmap_animation.gif")
        make_gif_from_pngs(heatmap_folder, output_gif_path, fps=fps)


def make_radius_histograms(rpm_grid,results_folder, histogram_df, make_gifs=True, verbose=False, fps=0.5, is_flat_density=False,make_cumulative=True):
    """Make heatmaps iterating through radius."""
    if not is_flat_density: heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","normal","radius")
    if is_flat_density: heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","flat_density","radius")
    os.makedirs(heatmap_folder, exist_ok=True)

    cumulative_hist_slices = []
    xedges = None
    yedges = None
    vmax = 0
    for i in range(len(rpm_grid.radius_grid_array) - 1): # Figure out what the max value of the histogram is going to be.
        lower_radius = rpm_grid.radius_grid_array[i]
        upper_radius = rpm_grid.radius_grid_array[i + 1]


        radius_filtered_df = histogram_df[(histogram_df["R_pE"] > lower_radius) & (histogram_df["R_pE"] <= upper_radius)]
        period_data = radius_filtered_df["Period_days"].values
        mass_data = radius_filtered_df["M_pE"].values
        weights = radius_filtered_df["mass_divided_weights"].values

        hist, xedges, yedges = np.histogram2d(mass_data, period_data, 
                                              bins=[rpm_grid.mass_grid_array, rpm_grid.period_grid_array], 
                                              weights=weights)  
        hist /= 1000
        
        cumulative_hist_slices.append(hist)

        vmax = max(vmax, np.nanmax(hist))

    for i in range(len(rpm_grid.radius_grid_array) - 1):
        lower_radius = rpm_grid.radius_grid_array[i]
        upper_radius = rpm_grid.radius_grid_array[i + 1]

        radius_filtered_df = histogram_df[(histogram_df["R_pE"] > lower_radius) & (histogram_df["R_pE"] <= upper_radius)]
        period_data = radius_filtered_df["Period_days"].values
        mass_data = radius_filtered_df["M_pE"].values
        weights = radius_filtered_df["mass_divided_weights"].values

        M_30_prior_upper = ((4/3)*np.pi*30/MEG)*(upper_radius * RECM)**3
        M_30_prior_lower = ((4/3)*np.pi*30/MEG)*(lower_radius * RECM)**3         

        M_001_prior_upper = ((4/3)*np.pi*0.01/MEG)*(upper_radius * RECM)**3
        M_001_prior_lower = ((4/3)*np.pi*0.01/MEG)*(lower_radius * RECM)**3

        hist, xedges, yedges = np.histogram2d(mass_data, period_data, 
                                              bins=[rpm_grid.mass_grid_array, rpm_grid.period_grid_array], 
                                              weights=weights)

        hist /= 1000

        plt.figure(figsize=(8, 6), dpi=200)

        ax = sns.heatmap(hist, annot=True, fmt=".4f", cbar=False, 
                         cmap=plt.cm.Spectral, vmin=0, vmax=vmax, annot_kws={"size": 5})


        for prior_line in [M_30_prior_upper,M_30_prior_lower,M_001_prior_upper,M_001_prior_lower]:
            heatmap_prior_lines(ax,rpm_grid.period_grid_array,rpm_grid.mass_grid_array,prior_line)

        ax.set_xticks(np.arange(len(yedges)))
        ax.set_xticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in yedges], 
                            fontsize=5)

        ax.set_yticks(np.arange(len(xedges)))
        ax.set_yticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in xedges],rotation=90, fontsize=5)

        ax.invert_yaxis()

        plt.xlabel('Period [days]')
        plt.ylabel('Mass [$M_{Earth}$]')

        plt.suptitle("Occurrence-Weighted Fraction of PhoDyMM Kepler Systems", fontsize=15)
        if is_flat_density: plt.title(f"Flat Density,  R={lower_radius}-{upper_radius}")
        if not is_flat_density: plt.title(f"R={lower_radius}-{upper_radius}")

        if not is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"R{lower_radius}-{upper_radius}_heatmap.png"), dpi=200)
        if is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"R{lower_radius}-{upper_radius}_flat_density_heatmap.png"), dpi=200)
        if verbose: 
            print(f"made R{lower_radius}-{upper_radius}_heatmap.png")
        plt.close()

    if make_cumulative:
        base_hist = cumulative_hist_slices[0] - cumulative_hist_slices[0]
        for hist in cumulative_hist_slices:
            base_hist += hist
        
        vmax = np.max(base_hist)
        plt.figure(figsize=(8, 6), dpi=200)

        ax = sns.heatmap(base_hist, annot=True, fmt=".4f", cbar=False, 
                         cmap=plt.cm.Spectral, vmin=0, vmax=vmax, annot_kws={"size": 5})
        
        ax.set_xticks(np.arange(len(yedges)))
        ax.set_xticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in yedges], 
                            fontsize=5)

        ax.set_yticks(np.arange(len(xedges)))
        ax.set_yticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in xedges],rotation=90, fontsize=5)

        ax.invert_yaxis()

        plt.xlabel('Period [days]')
        plt.ylabel('Mass [$M_{Earth}$]')

        plt.suptitle("Occurrence-Weighted Fraction of PhoDyMM Kepler Systems", fontsize=15)
        if is_flat_density: plt.title(f"Flat Density, Cumulative Radius")
        if not is_flat_density: plt.title(f"Cumulative Radius")

        if not is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"cumulative_radius_heatmap.png"), dpi=200)
        if is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"cumulative_radius_flat_density_heatmap.png"), dpi=200)
            
        if verbose:
            print(f"made cumulative_radius_heatmap.png")
        plt.close()
        
    if make_gifs:
        if not is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","normal"), exist_ok=True)
        if is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","flat_density"), exist_ok=True)
        if not is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps","normal", "radius_heatmap_animation.gif")
        if is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps","flat_density", "radius_flat_density_heatmap_animation.gif")
        make_gif_from_pngs(heatmap_folder, output_gif_path, fps=fps)      


def make_period_histograms(rpm_grid,results_folder, histogram_df, make_gifs=True, verbose=False, fps=0.5, is_flat_density=False,make_cumulative=True):
    """Make heatmaps iterating through period"""
    if not is_flat_density: heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","normal","period")
    if is_flat_density: heatmap_folder = os.path.join(results_folder, "plots", "heatmaps","flat_density","period")
    os.makedirs(heatmap_folder, exist_ok=True)

    cumulative_hist_slices = []
    xedges = None
    yedges = None
    vmax = 0
    for i in range(len(rpm_grid.period_grid_array) - 1): # Figure out what the max value of the histogram is going to be.
        lower_period = rpm_grid.period_grid_array[i]
        upper_period = rpm_grid.period_grid_array[i + 1]
        period_filtered_df = histogram_df[(histogram_df["Period_days"] > lower_period) & (histogram_df["Period_days"] <= upper_period)]
        radius_data = period_filtered_df["R_pE"].values
        mass_data = period_filtered_df["M_pE"].values
        weights = period_filtered_df["mass_divided_weights"].values

        hist, xedges, yedges = np.histogram2d(radius_data, mass_data,
                                              bins=[rpm_grid.radius_grid_array, rpm_grid.mass_grid_array], 
                                              weights=weights)  
        hist /= 1000
        
        cumulative_hist_slices.append(hist)
        
        vmax = max(vmax, np.nanmax(hist))

    for i in range(len(rpm_grid.period_grid_array) - 1):
        lower_period = rpm_grid.period_grid_array[i]
        upper_period = rpm_grid.period_grid_array[i + 1]

        period_filtered_df = histogram_df[(histogram_df["Period_days"] > lower_period) & (histogram_df["Period_days"] <= upper_period)]
        radius_data = period_filtered_df["R_pE"].values
        mass_data = period_filtered_df["M_pE"].values
        weights = period_filtered_df["mass_divided_weights"].values

        hist, xedges, yedges = np.histogram2d(radius_data, mass_data,
                                              bins=[rpm_grid.radius_grid_array, rpm_grid.mass_grid_array], 
                                              weights=weights)

        hist /= 1000
        plt.figure(figsize=(8, 6), dpi=200)

        ax = sns.heatmap(hist, annot=True, fmt=".4f", cbar=False, 
                         cmap=plt.cm.Spectral, vmin=0, vmax=vmax,annot_kws={"size": 5})

        ax.set_xticks(np.arange(len(yedges)))
        ax.set_xticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in yedges], 
                            fontsize=5)

        ax.set_yticks(np.arange(len(xedges)))
        ax.set_yticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in xedges],rotation=90, fontsize=5)

        ax.invert_yaxis()

        plt.ylabel('Radius [$R_{Earth}$]')
        plt.xlabel('Mass [$M_{Earth}$]')

        plt.suptitle("Occurrence-Weighted Fraction of PhoDyMM Kepler Systems", fontsize=15)
        if not is_flat_density: plt.title(f"P={lower_period}-{upper_period}")
        if is_flat_density: plt.title(f"Flat Density, P={lower_period}-{upper_period}")

        if not is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"P{lower_period}-{upper_period}_heatmap.png"), dpi=200)
        if is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"P{lower_period}-{upper_period}_flat_density_heatmap.png"), dpi=200)
        if verbose: 
            print(f"made P{lower_period}-{upper_period}_heatmap.png")
        plt.close()
        
    if make_cumulative:
        base_hist = cumulative_hist_slices[0] - cumulative_hist_slices[0]
        for hist in cumulative_hist_slices:
            base_hist += hist
        
        vmax = np.max(base_hist)
        plt.figure(figsize=(8, 6), dpi=200)

        ax = sns.heatmap(base_hist, annot=True, fmt=".4f", cbar=False, 
                         cmap=plt.cm.Spectral, vmin=0, vmax=vmax, annot_kws={"size": 5})
        
        ax.set_xticks(np.arange(len(yedges)))
        ax.set_xticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in yedges], 
                            fontsize=5)

        ax.set_yticks(np.arange(len(xedges)))
        ax.set_yticklabels([f"{edge:.2f}" if edge < 1e5 else f"{edge:.2e}" for edge in xedges],rotation=90, fontsize=5)

        ax.invert_yaxis()

        plt.ylabel('Radius [$R_{Earth}$]')
        plt.xlabel('Mass [$M_{Earth}$]')

        plt.suptitle("Occurrence-Weighted Fraction of PhoDyMM Kepler Systems", fontsize=15)
        if is_flat_density: plt.title(f"Flat Density, Cumulative Period")
        if not is_flat_density: plt.title(f"Cumulative Radius")

        if not is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"cumulative_period_heatmap.png"), dpi=200)
        if is_flat_density: plt.savefig(os.path.join(heatmap_folder, f"cumulative_period_flat_density_heatmap.png"), dpi=200)
            
        if verbose:
            print(f"made cumulative_period_heatmap.png")
        plt.close()

    if make_gifs:
        if not is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","normal"), exist_ok=True)
        if is_flat_density: os.makedirs(os.path.join(results_folder, "plots", "animations","heatmaps","flat_density"), exist_ok=True)
        if not is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations","heatmaps", "normal", "period_heatmap_animation.gif")
        if is_flat_density: output_gif_path = os.path.join(results_folder, "plots", "animations", "heatmaps","flat_density","period_flat_density_heatmap_animation.gif")
        make_gif_from_pngs(heatmap_folder, output_gif_path, fps=fps)   


def heatmap_prior_lines(ax,x_bins,y_bins,prior_line_y):
    """Helps to plot the prior lines on the heatmaps."""
    if prior_line_y > np.max(y_bins):
        return 

    # Find the lower bin edge that encloses the prior line.
    bin_idx = np.searchsorted(y_bins, prior_line_y) - 1 

    # Make linear interpolation between bin edges.
    y_lower, y_upper = y_bins[bin_idx], y_bins[bin_idx + 1]
    frac = (prior_line_y - y_lower) / (y_upper - y_lower) 
    mapped_y = bin_idx + frac 

    # Plot the precise horizontal line.
    ax.hlines(y=mapped_y, xmin=0, xmax=len(x_bins)-1, colors='k', linestyles='dashed')


def make_gif_from_pngs(input_dir, output_gif_path, fps=1,verbose=True):
    """Make gifs from the stacked heatmap sequences iterating through mass, period, or radius"""
    png_files = [f for f in os.listdir(input_dir) if f.endswith('.png')]
    
    file_numbers_dict = {} # Make dict with all the right png files.
    for file in png_files:
        m = re.search('\d+\.\d+',file)
        if m:
            value = float(m.group(0))
            file_numbers_dict[value] = file
        else:
            file_numbers_dict[9e99] = file
    
    print(sorted(file_numbers_dict))
    images = []
    for key in sorted(file_numbers_dict): # Sort them, then create a gif out of it.
        image_path = os.path.join(input_dir, file_numbers_dict[key])
        image = Image.open(image_path)
        images.append(image)
        
    os.makedirs(os.path.dirname(output_gif_path), exist_ok=True)
    
    durations = np.ones(len(images))*1000/fps
    
    durations[-1] = 4 * 1000/fps
    
    durations = durations.astype(int).tolist()

    images[0].save(output_gif_path, save_all=True, append_images=images[1:], optimize=True, duration=durations, loop=0)

    if verbose: print(f"GIF saved to {output_gif_path}")
        
        
 ### some kind of best fit plot        
 ### residuals (best fit - data)

    
def trace_plot(voxel_id,results_folder):
    trace_plot_folder = os.path.join(results_folder, "plots", "traces","basic_grid")
    os.makedirs(trace_plot_folder, exist_ok=True)
    sampler_backend_folder = results_folder + "/backend"
    
    filename = find_h5_file(voxel_id,sampler_backend_folder)
    file_path = os.path.join(sampler_backend_folder, filename)

    reader = emcee.backends.HDFBackend(file_path)

    samples = reader.get_chain()
    print("Chain shape:", samples.shape)
    n_steps, n_walkers, n_dim = samples.shape
    samples = np.array(samples)
    
    plt.figure(figsize=(10,5),dpi=150)
    for walker_data in samples.transpose(1,0,2):
        walker_data = np.squeeze(walker_data)
        plt.plot(np.linspace(0,n_steps,n_steps), walker_data)
    
    plt.xlabel("Step Number")
    plt.ylabel("Parameter value")
    plt.suptitle("Trace Plot",fontsize=17)
    plt.title(f"voxel: {voxel_id}")
    plt.savefig(trace_plot_folder+f"/{voxel_id}_trace.png", dpi=150)
    
    
def find_h5_file(voxel_id,sampler_backend_folder):
    voxel_id = str(voxel_id)
    h5_path = ""
    h5_files = [f for f in os.listdir(sampler_backend_folder) if f.endswith('.h5')]
    for file in h5_files:
        m = re.search("_"+voxel_id+"_",file)
        if m:
            h5_path = file
            break
    if not h5_path:
        return
    return h5_path


def corner_plot(voxel_id, results_folder):
    corner_plot_folder = os.path.join(results_folder, "plots", "corners","basic_grid")
    os.makedirs(corner_plot_folder, exist_ok=True)
    sampler_backend_folder = results_folder + "/backend"
    
    filename = find_h5_file(voxel_id,sampler_backend_folder)
    file_path = os.path.join(sampler_backend_folder, filename)

    reader = emcee.backends.HDFBackend(file_path)

    samples = reader.get_chain()
    print("Chain shape:", samples.shape)
    n_steps, n_walkers, n_dim = samples.shape
    samples = np.array(samples)
    
    corner_plot = corner.corner(samples.reshape(-1,1),labels=["$\mathcal{R}_{MRP}$"])
    plt.title(f"voxel: {voxel_id}")
    
    corner_plot.savefig(corner_plot_folder+f"/{voxel_id}_corner.png",dpi=150)

# chain_data = np.array(chains['chain'])  # shape: (nsteps, nwalkers, ndim)

# for walker_chain in chain_data.transpose(1, 0, 2):  # loop over walkers
#     plt.plot(walker_chain.squeeze())  # squeeze in case ndim == 1

# plt.xlabel("Step")
# plt.ylabel("Parameter value")
# plt.title("Walker chains")
# plt.show()
        
        
def main():
    
    cwd = os.getcwd()

    # Find the plotprops path.
    if 'src' in cwd:
        plotprops_filename = "../runs/plotprops.txt"
    elif 'runs' in cwd:
        plotprops_filename = "plotprops.txt"
    elif 'results' in cwd:
        plotprops_filename = "plotprops.txt"
    else:
        print('you are not starting from a proper directory. you should run kg_plots.py from a src, runs, or a results directory.')
        sys.exit()
        
    # Get plotprops loaded in.
    getData = ReadJson(plotprops_filename)
    plotprops = getData.outProps()
    verbose = plotprops.get("verbose")
    plottype = plotprops.get("plottype")
    input_data_filename = plotprops.get("input_data_filename")
    results_folder = plotprops.get("results_folder")
    make_gifs = plotprops.get("make_gifs")
    fps = plotprops.get("fps")
    make_cumulative_hist = plotprops.get("make_cumulative_hist")
    voxel_id = plotprops.get("voxel_id")
    print("Plotting: ", plottype)
    
    voxel_grid = RPMGrid(radius_grid_array,period_grid_array,mass_grid_array)

    if plottype in ["heatmap","heatmap_flat_density"]:
        df = pd.read_csv(input_data_filename)
        voxel_grid.setup_dataframes(df.columns)
        voxel_grid.add_data(df)
        voxel_grid.make_mass_divided_weights()

    plot_all = plottype == "all"
    
    # Actually make the plots.
    if plot_all or plottype == "heatmap":
        heatmap_plot(voxel_grid,results_folder,make_gifs=make_gifs,verbose=verbose,fps=fps,make_cumulative=make_cumulative_hist)
        
    if plot_all or plottype == "heatmap_flat_density":
        heatmap_plot(voxel_grid,results_folder,make_gifs=make_gifs,verbose=verbose,fps=fps,is_flat_density=True,make_cumulative=make_cumulative_hist)
        
    if plottype == "trace":
        
        trace_plot(voxel_id,results_folder)
        
    if plottype == "corner":
        
        corner_plot(voxel_id, results_folder)
        
    
    
if __name__ == "__main__":
    main()